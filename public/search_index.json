[["index.html", "Matplotlib with Rmarkdown Preface", " Matplotlib with Rmarkdown Alfonso R. Reyes 2020-11-02 Preface The goal of r-test-matplotlib is testing that Python matplotlib works seamlessly from within RStudio. Making matplotlib run from within RStudio using the R package reticulate and Python Anaconda has improved a lot in the past few months. The package reticulate and RStudio have gone through a thorough transformation and now seems to be an accepted fact that Python and R have to get along. "],["introduction.html", "Ch. 1 Introduction 1.1 The “hello world” plot", " Ch. 1 Introduction library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4]) plt.ylabel(&#39;some numbers&#39;) plt.show() 1.1 The “hello world” plot import matplotlib.pyplot as plt import numpy as np t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2*np.pi*t) plt.plot(t, s) plt.xlabel(&#39;time (s)&#39;) plt.ylabel(&#39;voltage (mV)&#39;) plt.title(&#39;About as simple as it gets, folks&#39;) plt.grid(True) plt.savefig(&quot;test.png&quot;) plt.show() # https://matplotlib.org/2.0.2/examples/mplot3d/contour3d_demo.html from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) cset = ax.contour(X, Y, Z, cmap=cm.coolwarm) ax.clabel(cset, fontsize=9, inline=1) plt.show() # https://matplotlib.org/gallery/showcase/anatomy.html#sphx-glr-gallery-showcase-anatomy-py import numpy as np import matplotlib.pyplot as plt from matplotlib.ticker import AutoMinorLocator, MultipleLocator, FuncFormatter np.random.seed(19680801) X = np.linspace(0.5, 3.5, 100) Y1 = 3+np.cos(X) Y2 = 1+np.cos(1+X/0.75)/2 Y3 = np.random.uniform(Y1, Y2, len(X)) fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(1, 1, 1, aspect=1) def minor_tick(x, pos): if not x % 1.0: return &quot;&quot; return &quot;%.2f&quot; % x ax.xaxis.set_major_locator(MultipleLocator(1.000)) ax.xaxis.set_minor_locator(AutoMinorLocator(4)) ax.yaxis.set_major_locator(MultipleLocator(1.000)) ax.yaxis.set_minor_locator(AutoMinorLocator(4)) ax.xaxis.set_minor_formatter(FuncFormatter(minor_tick)) ax.set_xlim(0, 4) #:&gt; (0.0, 4.0) ax.set_ylim(0, 4) #:&gt; (0.0, 4.0) ax.tick_params(which=&#39;major&#39;, width=1.0) ax.tick_params(which=&#39;major&#39;, length=10) ax.tick_params(which=&#39;minor&#39;, width=1.0, labelsize=10) ax.tick_params(which=&#39;minor&#39;, length=5, labelsize=10, labelcolor=&#39;0.25&#39;) ax.grid(linestyle=&quot;--&quot;, linewidth=0.5, color=&#39;.25&#39;, zorder=-10) ax.plot(X, Y1, c=(0.25, 0.25, 1.00), lw=2, label=&quot;Blue signal&quot;, zorder=10) ax.plot(X, Y2, c=(1.00, 0.25, 0.25), lw=2, label=&quot;Red signal&quot;) ax.plot(X, Y3, linewidth=0, marker=&#39;o&#39;, markerfacecolor=&#39;w&#39;, markeredgecolor=&#39;k&#39;) ax.set_title(&quot;Anatomy of a figure&quot;, fontsize=20, verticalalignment=&#39;bottom&#39;) ax.set_xlabel(&quot;X axis label&quot;) ax.set_ylabel(&quot;Y axis label&quot;) ax.legend() def circle(x, y, radius=0.15): from matplotlib.patches import Circle from matplotlib.patheffects import withStroke circle = Circle((x, y), radius, clip_on=False, zorder=10, linewidth=1, edgecolor=&#39;black&#39;, facecolor=(0, 0, 0, .0125), path_effects=[withStroke(linewidth=5, foreground=&#39;w&#39;)]) ax.add_artist(circle) def text(x, y, text): ax.text(x, y, text, backgroundcolor=&quot;white&quot;, ha=&#39;center&#39;, va=&#39;top&#39;, weight=&#39;bold&#39;, color=&#39;blue&#39;) # Minor tick circle(0.50, -0.10) text(0.50, -0.32, &quot;Minor tick label&quot;) # Major tick circle(-0.03, 4.00) text(0.03, 3.80, &quot;Major tick&quot;) # Minor tick circle(0.00, 3.50) text(0.00, 3.30, &quot;Minor tick&quot;) # Major tick label circle(-0.15, 3.00) text(-0.15, 2.80, &quot;Major tick label&quot;) # X Label circle(1.80, -0.27) text(1.80, -0.45, &quot;X axis label&quot;) # Y Label circle(-0.27, 1.80) text(-0.27, 1.6, &quot;Y axis label&quot;) # Title circle(1.60, 4.13) text(1.60, 3.93, &quot;Title&quot;) # Blue plot circle(1.75, 2.80) text(1.75, 2.60, &quot;Line\\n(line plot)&quot;) # Red plot circle(1.20, 0.60) text(1.20, 0.40, &quot;Line\\n(line plot)&quot;) # Scatter plot circle(3.20, 1.75) text(3.20, 1.55, &quot;Markers\\n(scatter plot)&quot;) # Grid circle(3.00, 3.00) text(3.00, 2.80, &quot;Grid&quot;) # Legend circle(3.70, 3.80) text(3.70, 3.60, &quot;Legend&quot;) # Axes circle(0.5, 0.5) text(0.5, 0.3, &quot;Axes&quot;) # Figure circle(-0.3, 0.65) text(-0.3, 0.45, &quot;Figure&quot;) color = &#39;blue&#39; ax.annotate(&#39;Spines&#39;, xy=(4.0, 0.35), xycoords=&#39;data&#39;, xytext=(3.3, 0.5), textcoords=&#39;data&#39;, weight=&#39;bold&#39;, color=color, arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3&quot;, color=color)) ax.annotate(&#39;&#39;, xy=(3.15, 0.0), xycoords=&#39;data&#39;, xytext=(3.45, 0.45), textcoords=&#39;data&#39;, weight=&#39;bold&#39;, color=color, arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3&quot;, color=color)) ax.text(4.0, -0.4, &quot;Made with http://matplotlib.org&quot;, fontsize=10, ha=&quot;right&quot;, color=&#39;.5&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt plt.style.use(&#39;ggplot&#39;) fig, axes = plt.subplots(ncols=2, nrows=2) ax1, ax2, ax3, ax4 = axes.ravel() # scatter plot (Note: `plt.scatter` doesn&#39;t use default colors) x, y = np.random.normal(size=(2, 200)) ax1.plot(x, y, &#39;o&#39;) # sinusoidal lines with colors from default color cycle L = 2*np.pi x = np.linspace(0, L) ncolors = len(plt.rcParams[&#39;axes.prop_cycle&#39;]) shift = np.linspace(0, L, ncolors, endpoint=False) for s in shift: ax2.plot(x, np.sin(x + s), &#39;-&#39;) ax2.margins(0) # bar graphs x = np.arange(5) y1, y2 = np.random.randint(1, 25, size=(2, 5)) width = 0.25 ax3.bar(x, y1, width) ax3.bar(x + width, y2, width, color=list(plt.rcParams[&#39;axes.prop_cycle&#39;])[2][&#39;color&#39;]) ax3.set_xticks(x + width) ax3.set_xticklabels([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]) # circles with colors from default color cycle for i, color in enumerate(plt.rcParams[&#39;axes.prop_cycle&#39;]): xy = np.random.normal(size=2) ax4.add_patch(plt.Circle(xy, radius=0.3, color=color[&#39;color&#39;])) ax4.axis(&#39;equal&#39;) ax4.margins(0) plt.show() # https://matplotlib.org/gallery/lines_bars_and_markers/cohere.html#sphx-glr-gallery-lines-bars-and-markers-cohere-py import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) dt = 0.01 t = np.arange(0, 30, dt) nse1 = np.random.randn(len(t)) # white noise 1 nse2 = np.random.randn(len(t)) # white noise 2 # Two signals with a coherent part at 10Hz and a random part s1 = np.sin(2 * np.pi * 10 * t) + nse1 s2 = np.sin(2 * np.pi * 10 * t) + nse2 fig, axs = plt.subplots(2, 1) axs[0].plot(t, s1, t, s2) axs[0].set_xlim(0, 2) axs[0].set_xlabel(&#39;time&#39;) axs[0].set_ylabel(&#39;s1 and s2&#39;) axs[0].grid(True) cxy, f = axs[1].cohere(s1, s2, 256, 1. / dt) axs[1].set_ylabel(&#39;coherence&#39;) fig.tight_layout() plt.show() "],["python-environment.html", "Ch. 2 Python environment", " Ch. 2 Python environment library(reticulate) # get the current folder of the notebook to set the relative path getwd() library(reticulate) use_condaenv(&quot;r-python&quot;, required = TRUE) py_config() reticulate::use_python(&quot;..\\\\..\\\\python-3.6.7.amd64\\\\python.exe&quot;) reticulate::py_config() reticulate::py_available() # this chunk with matplotlib will only run if the PyQt plugin path has been specified import matplotlib import matplotlib.pyplot as plt import numpy as np t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2 * np.pi * t) fig, ax = plt.subplots() ax.plot(t, s) ax.set(xlabel=&#39;time (s)&#39;, ylabel=&#39;voltage (mV)&#39;, title=&#39;About as simple as it gets, folks&#39;) ax.grid() plt.show() # load the package that makes R and Python talk library(reticulate) # set the preferred Python to execute user_profile &lt;- Sys.getenv(&quot;USERPROFILE&quot;) # user folder python_portable &lt;- normalizePath(file.path(user_profile, # Python location &quot;WPy-3710zero/python-3.7.1.amd64/python.exe&quot;)) reticulate::use_python(python_portable, required = TRUE) reticulate::py_config() # library(reticulate) # reticulate::use_python(&quot;..\\\\..\\\\python-3.6.7.amd64\\\\python.exe&quot;) # reticulate::py_config() # reticulate::py_available() "],["sharing-data-objects.html", "Ch. 3 Sharing data objects", " Ch. 3 Sharing data objects Always load the Python environment you are sure has the packages library(reticulate) use_condaenv(&quot;r-python&quot;, required = TRUE) reticulate::use_python(&quot;..\\\\..\\\\python-3.6.7.amd64\\\\python.exe&quot;) reticulate::py_config() reticulate::py_available() #R autos = cars #Python import numpy import pandas autos_py = r.autos autos_py[&#39;time&#39;]=autos_py[&#39;dist&#39;]/autos_py[&#39;speed&#39;] #R plot(py$autos_py) "],["math.html", "Ch. 4 Math 4.1 Middle 4.2 Surface functions 4.3 Machine Learning", " Ch. 4 Math library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) # https://www.geeksforgeeks.org/plot-mathematical-expressions-in-python-using-matplotlib/ # Import libraries import matplotlib.pyplot as plt import numpy as np x = np.linspace(-6, 6, 50) fig = plt.figure(figsize = (14, 8)) # Plot y = cos(x) y = np.cos(x) plt.plot(x, y, &#39;b&#39;, label =&#39;cos(x)&#39;) # Plot degree 2 Taylor polynomial y2 = 1 - x**2 / 2 plt.plot(x, y2, &#39;r-.&#39;, label =&#39;Degree 2&#39;) # Plot degree 4 Taylor polynomial y4 = 1 - x**2 / 2 + x**4 / 24 plt.plot(x, y4, &#39;g:&#39;, label =&#39;Degree 4&#39;) # Add features to our figure plt.legend() plt.grid(True, linestyle =&#39;:&#39;) plt.xlim([-6, 6]) plt.ylim([-4, 4]) plt.title(&#39;Taylor Polynomials of cos(x) at x = 0&#39;) plt.xlabel(&#39;x-axis&#39;) plt.ylabel(&#39;y-axis&#39;) # Show plot plt.show() # https://www.kaggle.com/sskiing/matplotlib-showcase-examples import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Polygon def func(x): return (x - 3) * (x - 5) * (x - 7) + 85 a, b = 2, 9 # integral limits x = np.linspace(0, 10) y = func(x) fig, ax = plt.subplots(dpi=200) plt.plot(x, y, &#39;r&#39;, linewidth=2) plt.ylim(ymin=0) # Make the shaded region ix = np.linspace(a, b) iy = func(ix) verts = [(a, 0)] + list(zip(ix, iy)) + [(b, 0)] poly = Polygon(verts, facecolor=&#39;0.9&#39;, edgecolor=&#39;0.5&#39;) ax.add_patch(poly) plt.text(0.5 * (a + b), 30, r&quot;$\\int_a^b f(x)\\mathrm{d}x$&quot;, horizontalalignment=&#39;center&#39;, fontsize=20) plt.figtext(0.9, 0.05, &#39;$x$&#39;) plt.figtext(0.1, 0.9, &#39;$y$&#39;) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.set_xticks((a, b)) ax.set_xticklabels((&#39;$a$&#39;, &#39;$b$&#39;)) ax.set_yticks([]) plt.show() 4.1 Middle # =================================== # 3D wireframe plots in one direction # =================================== # Demonstrates that setting rstride or cstride to 0 causes wires to not be # generated in the corresponding direction. from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig, [ax1, ax2] = plt.subplots(2, 1, figsize=(8, 12), subplot_kw={&#39;projection&#39;: &#39;3d&#39;}) # Get the test data X, Y, Z = axes3d.get_test_data(0.05) # Give the first plot only wireframes of the type y = c ax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0) ax1.set_title(&quot;Column (x) stride set to 0&quot;) # Give the second plot only wireframes of the type x = c ax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10) ax2.set_title(&quot;Row (y) stride set to 0&quot;) plt.tight_layout() plt.show() import matplotlib.pyplot as plt import numpy as np t = np.arange(0.0, 2.0, 0.01) s1 = np.sin(2 * np.pi * t) s2 = np.exp(-t) s3 = s1 * s2 fig, axs = plt.subplots(3, 1, sharex=True) # Remove horizontal space between axes fig.subplots_adjust(hspace=0) # Plot each graph, and manually set the y tick values axs[0].plot(t, s1) axs[0].set_yticks(np.arange(-0.9, 1.0, 0.4)) axs[0].set_ylim(-1, 1) axs[1].plot(t, s2) axs[1].set_yticks(np.arange(0.1, 1.0, 0.2)) axs[1].set_ylim(0, 1) axs[2].plot(t, s3) axs[2].set_yticks(np.arange(-0.9, 1.0, 0.4)) axs[2].set_ylim(-1, 1) plt.show() # http://www.scipy-lectures.org/intro/matplotlib/auto_examples/plot_plot3d_ex.html import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = Axes3D(fig) X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X ** 2 + Y ** 2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.hot) ax.contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-2, cmap=plt.cm.hot) ax.set_zlim(-2, 2) plt.show() # https://www.python-course.eu/matplotlib_multiple_figures.php import numpy as np import matplotlib.pyplot as plt def f(t): return np.exp(-t) * np.cos(2*np.pi*t) def g(t): return np.sin(t) * np.cos(1/(t+0.1)) t1 = np.arange(0.0, 5.0, 0.1) t2 = np.arange(0.0, 5.0, 0.02) plt.subplot(212) plt.plot(t1, g(t1), &#39;ro&#39;, t2, f(t2), &#39;k&#39;) plt.grid(color=&#39;b&#39;, alpha=0.5, linestyle=&#39;dashed&#39;, linewidth=0.5) plt.show() 4.2 Surface functions # https://matplotlib.org/gallery/mplot3d/offset.html#sphx-glr-gallery-mplot3d-offset-py # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) X, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25] Z = np.sqrt(np.abs(np.cos(X) + np.cos(Y))) ax.plot_surface(X + 1e5, Y + 1e5, Z, cmap=&#39;autumn&#39;, cstride=2, rstride=2) ax.set_xlabel(&quot;X label&quot;) ax.set_ylabel(&quot;Y label&quot;) ax.set_zlabel(&quot;Z label&quot;) ax.set_zlim(0, 2) plt.show() # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/surface3d_radial.py from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) # Create the mesh in polar coordinates and compute corresponding Z. r = np.linspace(0, 1.25, 50) p = np.linspace(0, 2*np.pi, 50) R, P = np.meshgrid(r, p) Z = ((R**2 - 1)**2) # Express the mesh in the cartesian system. X, Y = R*np.cos(P), R*np.sin(P) # Plot the surface. ax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r) # Tweak the limits and add latex math labels. ax.set_zlim(0, 1) ax.set_xlabel(r&#39;$\\phi_\\mathrm{real}$&#39;) ax.set_ylabel(r&#39;$\\phi_\\mathrm{im}$&#39;) ax.set_zlabel(r&#39;$V(\\phi)$&#39;) plt.show() # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/wire3d.py from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) # Grab some test data. X, Y, Z = axes3d.get_test_data(0.05) # Plot a basic wireframe. ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10) plt.show() from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) # Plot a sin curve using the x and y axes. x = np.linspace(0, 1, 100) y = np.sin(x * 2 * np.pi) / 2 + 0.5 ax.plot(x, y, zs=0, zdir=&#39;z&#39;, label=&#39;curve in (x,y)&#39;) # Plot scatterplot data (20 2D points per colour) on the x and z axes. colors = (&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;k&#39;) # Fixing random state for reproducibility np.random.seed(19680801) x = np.random.sample(20 * len(colors)) y = np.random.sample(20 * len(colors)) c_list = [] for c in colors: c_list.extend([c] * 20) # By using zdir=&#39;y&#39;, the y value of these points is fixed to the zs value 0 # and the (x,y) points are plotted on the x and z axes. ax.scatter(x, y, zs=0, zdir=&#39;y&#39;, c=c_list, label=&#39;points in (x,z)&#39;) # Make legend, set axes limits and labels ax.legend() ax.set_xlim(0, 1) ax.set_ylim(0, 1) ax.set_zlim(0, 1) ax.set_xlabel(&#39;X&#39;) ax.set_ylabel(&#39;Y&#39;) ax.set_zlabel(&#39;Z&#39;) # Customize the view angle so it&#39;s easier to see that the scatter points lie # on the plane y=0 ax.view_init(elev=20., azim=-35) plt.show() # https://matplotlib.org/2.0.2/examples/mplot3d/contour3d_demo.html from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) cset = ax.contour(X, Y, Z, cmap=cm.coolwarm) ax.clabel(cset, fontsize=9, inline=1) plt.show() 4.3 Machine Learning import numpy as np from matplotlib import pyplot as plt from sklearn import neighbors, datasets from matplotlib.colors import ListedColormap # Create color maps for 3-class classification problem, as with iris cmap_light = ListedColormap([&#39;#FFAAAA&#39;,&#39;#AAFFAA&#39;,&#39;#AAAAFF&#39;]) cmap_bold = ListedColormap([&#39;#FF0000&#39;,&#39;#00FF00&#39;,&#39;#0000FF&#39;]) iris = datasets.load_iris() X = iris.data[:, :2] # we only take the first two features. We could # avoid this ugly slicing by using a two-dim dataset y = iris.target knn = neighbors.KNeighborsClassifier(n_neighbors=1) knn.fit(X, y) x_min, x_max = X[:, 0].min() - .1, X[:, 0].max() + .1 y_min, y_max = X[:, 1].min() - .1, X[:, 1].max() + .1 xx, yy = np.meshgrid(np.linspace(x_min, x_max, 100), np.linspace(y_min, y_max, 100)) Z = knn.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) plt.figure() plt.pcolormesh(xx, yy, Z, cmap=cmap_light) # Plot also the training points plt.scatter(X[:, 0], X[:, 1], c=y, cmap=cmap_bold) plt.xlabel(&#39;sepal length (cm)&#39;) plt.ylabel(&#39;sepal width (cm)&#39;) plt.axis(&#39;tight&#39;) plt.show() "],["scientific.html", "Ch. 5 Scientific 5.1 Solve large scale eigenvalue problems 5.2 Computational Physics 5.3 Contour maps 5.4 Real time", " Ch. 5 Scientific library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 5.1 Solve large scale eigenvalue problems lobpcg (Locally Optimal Block Preconditioned Conjugate Gradient Method) * works very well in combination with PyAMG (example by Nathan Bell) # http://scipy-lectures.org/_downloads/ScipyLectures-simple.pdf # Page 348 # Compute eigenvectors and eigenvalues using a preconditioned eigensolver # ======================================================================== # # In this example Smoothed Aggregation (SA) is used to precondition # the LOBPCG eigensolver on a two-dimensional Poisson problem with # Dirichlet boundary conditions. import scipy from scipy.sparse.linalg import lobpcg import matplotlib.pyplot as plt from pyamg import smoothed_aggregation_solver from pyamg.gallery import poisson N = 100 K = 9 A = poisson((N,N), format=&#39;csr&#39;) # create the AMG hierarchy ml = smoothed_aggregation_solver(A) # initial approximation to the K eigenvectors X = scipy.rand(A.shape[0], K) # preconditioner based on ml M = ml.aspreconditioner() # compute eigenvalues and eigenvectors with LOBPCG W,V = lobpcg(A, X, M=M, tol=1e-8, largest=False) plt.figure(figsize=(9,9)) for i in range(K): plt.subplot(3, 3, i+1) plt.title(&#39;Eigenvector%d&#39;% i) plt.pcolor(V[:,i].reshape(N,N)) plt.axis(&#39;equal&#39;) plt.axis(&#39;off&#39;) plt.show() 5.2 Computational Physics # Plot of the Lorenz Attractor based on Edward Lorenz&#39;s 1963 &quot;Deterministic # Nonperiodic Flow&quot; publication. # http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorenz(x, y, z, s=10, r=28, b=2.667): x_dot = s*(y - x) y_dot = r*x - y - x*z z_dot = x*y - b*z return x_dot, y_dot, z_dot dt = 0.01 stepCnt = 10000 # Need one more for the initial values xs = np.empty((stepCnt + 1,)) ys = np.empty((stepCnt + 1,)) zs = np.empty((stepCnt + 1,)) # Setting initial values xs[0], ys[0], zs[0] = (0., 1., 1.05) # Stepping through &quot;time&quot;. for i in range(stepCnt): # Derivatives of the X, Y, Z state x_dot, y_dot, z_dot = lorenz(xs[i], ys[i], zs[i]) xs[i + 1] = xs[i] + (x_dot * dt) ys[i + 1] = ys[i] + (y_dot * dt) zs[i + 1] = zs[i] + (z_dot * dt) fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.plot(xs, ys, zs, lw=0.5) ax.set_xlabel(&quot;X Axis&quot;) ax.set_ylabel(&quot;Y Axis&quot;) ax.set_zlabel(&quot;Z Axis&quot;) ax.set_title(&quot;Lorenz Attractor&quot;) plt.show() # =================================== # 3D wireframe plots in one direction # =================================== # Demonstrates that setting rstride or cstride to 0 causes wires to not be # generated in the corresponding direction. from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig, [ax1, ax2] = plt.subplots(2, 1, figsize=(8, 12), subplot_kw={&#39;projection&#39;: &#39;3d&#39;}) # Get the test data X, Y, Z = axes3d.get_test_data(0.05) # Give the first plot only wireframes of the type y = c ax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0) ax1.set_title(&quot;Column (x) stride set to 0&quot;) # Give the second plot only wireframes of the type x = c ax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10) ax2.set_title(&quot;Row (y) stride set to 0&quot;) plt.tight_layout() plt.show() # https://matplotlib.org/gallery/images_contours_and_fields/contour_image.html#sphx-glr-gallery-images-contours-and-fields-contour-image-py import matplotlib.pyplot as plt import numpy as np from matplotlib import cm # Default delta is large because that makes it fast, and it illustrates # the correct registration between image and contours. delta = 0.5 extent = (-3, 4, -4, 3) x = np.arange(-3.0, 4.001, delta) y = np.arange(-4.0, 3.001, delta) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 # Boost the upper limit to avoid truncation errors. levels = np.arange(-2.0, 1.601, 0.4) norm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max()) cmap = cm.PRGn fig, _axs = plt.subplots(nrows=2, ncols=2) fig.subplots_adjust(hspace=0.3) axs = _axs.flatten() cset1 = axs[0].contourf(X, Y, Z, levels, norm=norm, cmap=cm.get_cmap(cmap, len(levels) - 1)) # It is not necessary, but for the colormap, we need only the # number of levels minus 1. To avoid discretization error, use # either this number or a large number such as the default (256). # If we want lines as well as filled regions, we need to call # contour separately; don&#39;t try to change the edgecolor or edgewidth # of the polygons in the collections returned by contourf. # Use levels output from previous call to guarantee they are the same. cset2 = axs[0].contour(X, Y, Z, cset1.levels, colors=&#39;k&#39;) # We don&#39;t really need dashed contour lines to indicate negative # regions, so let&#39;s turn them off. for c in cset2.collections: c.set_linestyle(&#39;solid&#39;) # It is easier here to make a separate call to contour than # to set up an array of colors and linewidths. # We are making a thick green line as a zero contour. # Specify the zero level as a tuple with only 0 in it. cset3 = axs[0].contour(X, Y, Z, (0,), colors=&#39;g&#39;, linewidths=2) axs[0].set_title(&#39;Filled contours&#39;) fig.colorbar(cset1, ax=axs[0]) axs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm) axs[1].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;upper&#39;, extent=extent) axs[1].set_title(&quot;Image, origin &#39;upper&#39;&quot;) axs[2].imshow(Z, origin=&#39;lower&#39;, extent=extent, cmap=cmap, norm=norm) axs[2].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;lower&#39;, extent=extent) axs[2].set_title(&quot;Image, origin &#39;lower&#39;&quot;) # We will use the interpolation &quot;nearest&quot; here to show the actual # image pixels. # Note that the contour lines don&#39;t extend to the edge of the box. # This is intentional. The Z values are defined at the center of each # image pixel (each color block on the following subplot), so the # domain that is contoured does not extend beyond these pixel centers. im = axs[3].imshow(Z, interpolation=&#39;nearest&#39;, extent=extent, cmap=cmap, norm=norm) axs[3].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;image&#39;, extent=extent) ylim = axs[3].get_ylim() axs[3].set_ylim(ylim[::-1]) axs[3].set_title(&quot;Origin from rc, reversed y-axis&quot;) fig.colorbar(im, ax=axs[3]) fig.tight_layout() plt.show() # step demo # https://matplotlib.org/gallery/lines_bars_and_markers/step_demo.html#sphx-glr-gallery-lines-bars-and-markers-step-demo-py import numpy as np from numpy import ma import matplotlib.pyplot as plt x = np.arange(1, 7, 0.4) y0 = np.sin(x) y = y0.copy() + 2.5 plt.step(x, y, label=&#39;pre (default)&#39;) y -= 0.5 plt.step(x, y, where=&#39;mid&#39;, label=&#39;mid&#39;) y -= 0.5 plt.step(x, y, where=&#39;post&#39;, label=&#39;post&#39;) y = ma.masked_where((y0 &gt; -0.15) &amp; (y0 &lt; 0.15), y - 0.5) plt.step(x, y, label=&#39;masked (pre)&#39;) plt.legend() plt.xlim(0, 7) plt.ylim(-0.5, 4) plt.show() # Plot of the Lorenz Attractor based on Edward Lorenz&#39;s 1963 &quot;Deterministic # Nonperiodic Flow&quot; publication. # http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorenz(x, y, z, s=10, r=28, b=2.667): x_dot = s*(y - x) y_dot = r*x - y - x*z z_dot = x*y - b*z return x_dot, y_dot, z_dot dt = 0.01 stepCnt = 10000 # Need one more for the initial values xs = np.empty((stepCnt + 1,)) ys = np.empty((stepCnt + 1,)) zs = np.empty((stepCnt + 1,)) # Setting initial values xs[0], ys[0], zs[0] = (0., 1., 1.05) # Stepping through &quot;time&quot;. for i in range(stepCnt): # Derivatives of the X, Y, Z state x_dot, y_dot, z_dot = lorenz(xs[i], ys[i], zs[i]) xs[i + 1] = xs[i] + (x_dot * dt) ys[i + 1] = ys[i] + (y_dot * dt) zs[i + 1] = zs[i] + (z_dot * dt) fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.plot(xs, ys, zs, lw=0.5) ax.set_xlabel(&quot;X Axis&quot;) ax.set_ylabel(&quot;Y Axis&quot;) ax.set_zlabel(&quot;Z Axis&quot;) ax.set_title(&quot;Lorenz Attractor&quot;) plt.show() # =================================== # 3D wireframe plots in one direction # =================================== # Demonstrates that setting rstride or cstride to 0 causes wires to not be # generated in the corresponding direction. from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig, [ax1, ax2] = plt.subplots(2, 1, figsize=(8, 12), subplot_kw={&#39;projection&#39;: &#39;3d&#39;}) # Get the test data X, Y, Z = axes3d.get_test_data(0.05) # Give the first plot only wireframes of the type y = c ax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0) ax1.set_title(&quot;Column (x) stride set to 0&quot;) # Give the second plot only wireframes of the type x = c ax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10) ax2.set_title(&quot;Row (y) stride set to 0&quot;) plt.tight_layout() plt.show() # https://matplotlib.org/gallery/images_contours_and_fields/contour_image.html#sphx-glr-gallery-images-contours-and-fields-contour-image-py import matplotlib.pyplot as plt import numpy as np from matplotlib import cm # Default delta is large because that makes it fast, and it illustrates # the correct registration between image and contours. delta = 0.5 extent = (-3, 4, -4, 3) x = np.arange(-3.0, 4.001, delta) y = np.arange(-4.0, 3.001, delta) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 # Boost the upper limit to avoid truncation errors. levels = np.arange(-2.0, 1.601, 0.4) norm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max()) cmap = cm.PRGn fig, _axs = plt.subplots(nrows=2, ncols=2) fig.subplots_adjust(hspace=0.3) axs = _axs.flatten() cset1 = axs[0].contourf(X, Y, Z, levels, norm=norm, cmap=cm.get_cmap(cmap, len(levels) - 1)) # It is not necessary, but for the colormap, we need only the # number of levels minus 1. To avoid discretization error, use # either this number or a large number such as the default (256). # If we want lines as well as filled regions, we need to call # contour separately; don&#39;t try to change the edgecolor or edgewidth # of the polygons in the collections returned by contourf. # Use levels output from previous call to guarantee they are the same. cset2 = axs[0].contour(X, Y, Z, cset1.levels, colors=&#39;k&#39;) # We don&#39;t really need dashed contour lines to indicate negative # regions, so let&#39;s turn them off. for c in cset2.collections: c.set_linestyle(&#39;solid&#39;) # It is easier here to make a separate call to contour than # to set up an array of colors and linewidths. # We are making a thick green line as a zero contour. # Specify the zero level as a tuple with only 0 in it. cset3 = axs[0].contour(X, Y, Z, (0,), colors=&#39;g&#39;, linewidths=2) axs[0].set_title(&#39;Filled contours&#39;) fig.colorbar(cset1, ax=axs[0]) axs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm) axs[1].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;upper&#39;, extent=extent) axs[1].set_title(&quot;Image, origin &#39;upper&#39;&quot;) axs[2].imshow(Z, origin=&#39;lower&#39;, extent=extent, cmap=cmap, norm=norm) axs[2].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;lower&#39;, extent=extent) axs[2].set_title(&quot;Image, origin &#39;lower&#39;&quot;) # We will use the interpolation &quot;nearest&quot; here to show the actual # image pixels. # Note that the contour lines don&#39;t extend to the edge of the box. # This is intentional. The Z values are defined at the center of each # image pixel (each color block on the following subplot), so the # domain that is contoured does not extend beyond these pixel centers. im = axs[3].imshow(Z, interpolation=&#39;nearest&#39;, extent=extent, cmap=cmap, norm=norm) axs[3].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;image&#39;, extent=extent) ylim = axs[3].get_ylim() axs[3].set_ylim(ylim[::-1]) axs[3].set_title(&quot;Origin from rc, reversed y-axis&quot;) fig.colorbar(im, ax=axs[3]) fig.tight_layout() plt.show() # https://matplotlib.org/gallery/lines_bars_and_markers/step_demo.html#sphx-glr-gallery-lines-bars-and-markers-step-demo-py import numpy as np from numpy import ma import matplotlib.pyplot as plt x = np.arange(1, 7, 0.4) y0 = np.sin(x) y = y0.copy() + 2.5 plt.step(x, y, label=&#39;pre (default)&#39;) y -= 0.5 plt.step(x, y, where=&#39;mid&#39;, label=&#39;mid&#39;) y -= 0.5 plt.step(x, y, where=&#39;post&#39;, label=&#39;post&#39;) y = ma.masked_where((y0 &gt; -0.15) &amp; (y0 &lt; 0.15), y - 0.5) plt.step(x, y, label=&#39;masked (pre)&#39;) plt.legend() plt.xlim(0, 7) plt.ylim(-0.5, 4) plt.show() # https://matplotlib.org/gallery/images_contours_and_fields/irregulardatagrid.html#sphx-glr-gallery-images-contours-and-fields-irregulardatagrid-py import matplotlib.pyplot as plt import matplotlib.tri as tri import numpy as np np.random.seed(19680801) npts = 200 ngridx = 100 ngridy = 200 x = np.random.uniform(-2, 2, npts) y = np.random.uniform(-2, 2, npts) z = x * np.exp(-x**2 - y**2) fig, (ax1, ax2) = plt.subplots(nrows=2) # ----------------------- # Interpolation on a grid # ----------------------- # A contour plot of irregularly spaced data coordinates # via interpolation on a grid. # Create grid values first. xi = np.linspace(-2.1, 2.1, ngridx) yi = np.linspace(-2.1, 2.1, ngridy) # Perform linear interpolation of the data (x,y) # on a grid defined by (xi,yi) triang = tri.Triangulation(x, y) interpolator = tri.LinearTriInterpolator(triang, z) Xi, Yi = np.meshgrid(xi, yi) zi = interpolator(Xi, Yi) # Note that scipy.interpolate provides means to interpolate data on a grid # as well. The following would be an alternative to the four lines above: #from scipy.interpolate import griddata #zi = griddata((x, y), z, (xi[None,:], yi[:,None]), method=&#39;linear&#39;) ax1.contour(xi, yi, zi, 14, linewidths=0.5, colors=&#39;k&#39;) cntr1 = ax1.contourf(xi, yi, zi, 14, cmap=&quot;RdBu_r&quot;) fig.colorbar(cntr1, ax=ax1) ax1.plot(x, y, &#39;ko&#39;, ms=3) ax1.axis((-2, 2, -2, 2)) ax1.set_title(&#39;grid and contour (%d points, %d grid points)&#39; % (npts, ngridx * ngridy)) # ---------- # Tricontour # ---------- # Directly supply the unordered, irregularly spaced coordinates # to tricontour. ax2.tricontour(x, y, z, 14, linewidths=0.5, colors=&#39;k&#39;) cntr2 = ax2.tricontourf(x, y, z, 14, cmap=&quot;RdBu_r&quot;) fig.colorbar(cntr2, ax=ax2) ax2.plot(x, y, &#39;ko&#39;, ms=3) ax2.axis((-2, 2, -2, 2)) ax2.set_title(&#39;tricontour (%d points)&#39; % npts) plt.subplots_adjust(hspace=0.5) plt.show() from matplotlib.tri import Triangulation, TriAnalyzer, UniformTriRefiner import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np #----------------------------------------------------------------------------- # Analytical test function #----------------------------------------------------------------------------- def experiment_res(x, y): &quot;&quot;&quot; An analytic function representing experiment results &quot;&quot;&quot; x = 2. * x r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2) theta1 = np.arctan2(0.5 - x, 0.5 - y) r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2) theta2 = np.arctan2(-x - 0.2, -y - 0.2) z = (4 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(3 * theta1) + (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(5 * theta2) + 2 * (x**2 + y**2)) return (np.max(z) - z) / (np.max(z) - np.min(z)) #----------------------------------------------------------------------------- # Generating the initial data test points and triangulation for the demo #----------------------------------------------------------------------------- # User parameters for data test points n_test = 200 # Number of test data points, tested from 3 to 5000 for subdiv=3 subdiv = 3 # Number of recursive subdivisions of the initial mesh for smooth # plots. Values &gt;3 might result in a very high number of triangles # for the refine mesh: new triangles numbering = (4**subdiv)*ntri init_mask_frac = 0.0 # Float &gt; 0. adjusting the proportion of # (invalid) initial triangles which will be masked # out. Enter 0 for no mask. min_circle_ratio = .01 # Minimum circle ratio - border triangles with circle # ratio below this will be masked if they touch a # border. Suggested value 0.01; use -1 to keep # all triangles. # Random points random_gen = np.random.RandomState(seed=19680801) x_test = random_gen.uniform(-1., 1., size=n_test) y_test = random_gen.uniform(-1., 1., size=n_test) z_test = experiment_res(x_test, y_test) # meshing with Delaunay triangulation tri = Triangulation(x_test, y_test) ntri = tri.triangles.shape[0] # Some invalid data are masked out mask_init = np.zeros(ntri, dtype=bool) masked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac)) mask_init[masked_tri] = True tri.set_mask(mask_init) #----------------------------------------------------------------------------- # Improving the triangulation before high-res plots: removing flat triangles #----------------------------------------------------------------------------- # masking badly shaped triangles at the border of the triangular mesh. mask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio) tri.set_mask(mask) # refining the data refiner = UniformTriRefiner(tri) tri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv) # analytical &#39;results&#39; for comparison z_expected = experiment_res(tri_refi.x, tri_refi.y) # for the demo: loading the &#39;flat&#39; triangles for plot flat_tri = Triangulation(x_test, y_test) flat_tri.set_mask(~mask) #----------------------------------------------------------------------------- # Now the plots #----------------------------------------------------------------------------- # User options for plots plot_tri = True # plot of base triangulation plot_masked_tri = True # plot of excessively flat excluded triangles plot_refi_tri = False # plot of refined triangulation plot_expected = False # plot of analytical function values for comparison # Graphical options for tricontouring levels = np.arange(0., 1., 0.025) cmap = cm.get_cmap(name=&#39;Blues&#39;, lut=None) fig, ax = plt.subplots() ax.set_aspect(&#39;equal&#39;) ax.set_title(&quot;Filtering a Delaunay mesh\\n&quot; + &quot;(application to high-resolution tricontouring)&quot;) # 1) plot of the refined (computed) data contours: ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap, linewidths=[2.0, 0.5, 1.0, 0.5]) # 2) plot of the expected (analytical) data contours (dashed): if plot_expected: ax.tricontour(tri_refi, z_expected, levels=levels, cmap=cmap, linestyles=&#39;--&#39;) # 3) plot of the fine mesh on which interpolation was done: if plot_refi_tri: ax.triplot(tri_refi, color=&#39;0.97&#39;) # 4) plot of the initial &#39;coarse&#39; mesh: if plot_tri: ax.triplot(tri, color=&#39;0.7&#39;) # 4) plot of the unvalidated triangles from naive Delaunay Triangulation: if plot_masked_tri: ax.triplot(flat_tri, color=&#39;red&#39;) plt.show() # https://matplotlib.org/gallery/images_contours_and_fields/triinterp_demo.html#sphx-glr-gallery-images-contours-and-fields-triinterp-demo-py import matplotlib.pyplot as plt import matplotlib.tri as mtri import numpy as np # Create triangulation. x = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5]) y = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0]) triangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7], [5, 6, 8], [5, 8, 7], [7, 8, 9]] triang = mtri.Triangulation(x, y, triangles) # Interpolate to regularly-spaced quad grid. z = np.cos(1.5 * x) * np.cos(1.5 * y) xi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20)) interp_lin = mtri.LinearTriInterpolator(triang, z) zi_lin = interp_lin(xi, yi) interp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=&#39;geom&#39;) zi_cubic_geom = interp_cubic_geom(xi, yi) interp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind=&#39;min_E&#39;) zi_cubic_min_E = interp_cubic_min_E(xi, yi) # Set up the figure fig, axs = plt.subplots(nrows=2, ncols=2) axs = axs.flatten() # Plot the triangulation. axs[0].tricontourf(triang, z) axs[0].triplot(triang, &#39;ko-&#39;) axs[0].set_title(&#39;Triangular grid&#39;) # Plot linear interpolation to quad grid. axs[1].contourf(xi, yi, zi_lin) axs[1].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[1].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[1].set_title(&quot;Linear interpolation&quot;) # Plot cubic interpolation to quad grid, kind=geom axs[2].contourf(xi, yi, zi_cubic_geom) axs[2].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[2].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[2].set_title(&quot;Cubic interpolation,\\nkind=&#39;geom&#39;&quot;) # Plot cubic interpolation to quad grid, kind=min_E axs[3].contourf(xi, yi, zi_cubic_min_E) axs[3].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[3].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[3].set_title(&quot;Cubic interpolation,\\nkind=&#39;min_E&#39;&quot;) fig.tight_layout() plt.show() # https://matplotlib.org/gallery/subplots_axes_and_figures/axhspan_demo.html#sphx-glr-gallery-subplots-axes-and-figures-axhspan-demo-py import numpy as np import matplotlib.pyplot as plt t = np.arange(-1, 2, .01) s = np.sin(2 * np.pi * t) plt.plot(t, s) # Draw a thick red hline at y=0 that spans the xrange plt.axhline(linewidth=8, color=&#39;#d62728&#39;) # Draw a default hline at y=1 that spans the xrange plt.axhline(y=1) # Draw a default vline at x=1 that spans the yrange plt.axvline(x=1) # Draw a thick blue vline at x=0 that spans the upper quadrant of the yrange plt.axvline(x=0, ymin=0.75, linewidth=8, color=&#39;#1f77b4&#39;) # Draw a default hline at y=.5 that spans the middle half of the axes plt.axhline(y=.5, xmin=0.25, xmax=0.75) plt.axhspan(0.25, 0.75, facecolor=&#39;0.5&#39;, alpha=0.5) plt.axvspan(1.25, 1.55, facecolor=&#39;#2ca02c&#39;, alpha=0.5) plt.axis([-1, 2, -1, 2]) plt.show() 5.3 Contour maps import matplotlib.pyplot as plt import numpy as np # http://www.scipy-lectures.org/intro/matplotlib/auto_examples/plot_contour_ex.html def f(x, y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 -y ** 2) n = 256 x = np.linspace(-3, 3, n) y = np.linspace(-3, 3, n) X,Y = np.meshgrid(x, y) plt.axes([0.025, 0.025, 0.95, 0.95]) plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.hot) C = plt.contour(X, Y, f(X, Y), 8, colors=&#39;black&#39;, linewidth=.5) plt.clabel(C, inline=1, fontsize=10) plt.xticks(()) plt.yticks(()) plt.show() from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) # Plot a sin curve using the x and y axes. x = np.linspace(0, 1, 100) y = np.sin(x * 2 * np.pi) / 2 + 0.5 ax.plot(x, y, zs=0, zdir=&#39;z&#39;, label=&#39;curve in (x,y)&#39;) # Plot scatterplot data (20 2D points per colour) on the x and z axes. colors = (&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;k&#39;) # Fixing random state for reproducibility np.random.seed(19680801) x = np.random.sample(20 * len(colors)) y = np.random.sample(20 * len(colors)) c_list = [] for c in colors: c_list.extend([c] * 20) # By using zdir=&#39;y&#39;, the y value of these points is fixed to the zs value 0 # and the (x,y) points are plotted on the x and z axes. ax.scatter(x, y, zs=0, zdir=&#39;y&#39;, c=c_list, label=&#39;points in (x,z)&#39;) # Make legend, set axes limits and labels ax.legend() ax.set_xlim(0, 1) ax.set_ylim(0, 1) ax.set_zlim(0, 1) ax.set_xlabel(&#39;X&#39;) ax.set_ylabel(&#39;Y&#39;) ax.set_zlabel(&#39;Z&#39;) # Customize the view angle so it&#39;s easier to see that the scatter points lie # on the plane y=0 ax.view_init(elev=20., azim=-35) plt.show() from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3) cset = ax.contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-100, cmap=cm.coolwarm) cset = ax.contourf(X, Y, Z, zdir=&#39;x&#39;, offset=-40, cmap=cm.coolwarm) cset = ax.contourf(X, Y, Z, zdir=&#39;y&#39;, offset=40, cmap=cm.coolwarm) ax.set_xlabel(&#39;X&#39;) ax.set_xlim(-40, 40) ax.set_ylabel(&#39;Y&#39;) ax.set_ylim(-40, 40) ax.set_zlabel(&#39;Z&#39;) ax.set_zlim(-100, 100) plt.show() 5.4 Real time # https://matplotlib.org/gallery/lines_bars_and_markers/cohere.html#sphx-glr-gallery-lines-bars-and-markers-cohere-py import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) dt = 0.01 t = np.arange(0, 30, dt) nse1 = np.random.randn(len(t)) # white noise 1 nse2 = np.random.randn(len(t)) # white noise 2 # Two signals with a coherent part at 10Hz and a random part s1 = np.sin(2 * np.pi * 10 * t) + nse1 s2 = np.sin(2 * np.pi * 10 * t) + nse2 fig, axs = plt.subplots(2, 1) axs[0].plot(t, s1, t, s2) axs[0].set_xlim(0, 2) axs[0].set_xlabel(&#39;time&#39;) axs[0].set_ylabel(&#39;s1 and s2&#39;) axs[0].grid(True) cxy, f = axs[1].cohere(s1, s2, 256, 1. / dt) axs[1].set_ylabel(&#39;coherence&#39;) fig.tight_layout() plt.show() # https://matplotlib.org/gallery/scales/symlog_demo.html#sphx-glr-gallery-scales-symlog-demo-py import matplotlib.pyplot as plt import numpy as np dt = 0.01 x = np.arange(-50.0, 50.0, dt) y = np.arange(0, 100.0, dt) plt.subplot(311) plt.plot(x, y) plt.xscale(&#39;symlog&#39;) plt.ylabel(&#39;symlogx&#39;) plt.grid(True) plt.gca().xaxis.grid(True, which=&#39;minor&#39;) # minor grid on too plt.subplot(312) plt.plot(y, x) plt.yscale(&#39;symlog&#39;) plt.ylabel(&#39;symlogy&#39;) plt.subplot(313) plt.plot(x, np.sin(x / 3.0)) plt.xscale(&#39;symlog&#39;) plt.yscale(&#39;symlog&#39;, linthreshy=0.015) plt.grid(True) plt.ylabel(&#39;symlog both&#39;) plt.tight_layout() plt.show() "],["voxels.html", "Ch. 6 Voxels", " Ch. 6 Voxels library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) # load the package that makes R and Python talk library(reticulate) # set the preferred Python to execute user_profile &lt;- Sys.getenv(&quot;USERPROFILE&quot;) # user folder python_portable &lt;- normalizePath(file.path(user_profile, # Python location &quot;WPy-3710zero/python-3.7.1.amd64/python.exe&quot;)) reticulate::use_python(python_portable, required = TRUE) # find out if it took it reticulate::py_config() # https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.axes3d.Axes3D.html #======================================================= #3D voxel / volumetric plot with cylindrical coordinates #======================================================= #Demonstrates using the ``x, y, z`` arguments of ``ax.voxels``. import matplotlib.pyplot as plt import matplotlib.colors import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def midpoints(x): sl = () for i in range(x.ndim): x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0 sl += np.index_exp[:] return x # prepare some coordinates, and attach rgb values to each r, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j] x = r*np.cos(theta) y = r*np.sin(theta) rc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z) # define a wobbly torus about [0.7, *, 0] sphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 &lt; 0.2**2 # combine the color components hsv = np.zeros(sphere.shape + (3,)) hsv[..., 0] = thetac / (np.pi*2) hsv[..., 1] = rc hsv[..., 2] = zc + 0.5 colors = matplotlib.colors.hsv_to_rgb(hsv) # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(x, y, z, sphere, facecolors=colors, edgecolors=np.clip(2*colors - 0.5, 0, 1), # brighter linewidth=0.5) plt.show() # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/voxels.py import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import # prepare some coordinates x, y, z = np.indices((8, 8, 8)) # draw cuboids in the top left and bottom right corners, and a link between them cube1 = (x &lt; 3) &amp; (y &lt; 3) &amp; (z &lt; 3) cube2 = (x &gt;= 5) &amp; (y &gt;= 5) &amp; (z &gt;= 5) link = abs(x - y) + abs(y - z) + abs(z - x) &lt;= 2 # combine the objects into a single boolean array voxels = cube1 | cube2 | link # set the colors of each object colors = np.empty(voxels.shape, dtype=object) colors[link] = &#39;red&#39; colors[cube1] = &#39;blue&#39; colors[cube2] = &#39;green&#39; # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(voxels, facecolors=colors, edgecolor=&#39;k&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) def explode(data): shape_arr = np.array(data.shape) size = shape_arr[:3]*2 - 1 exploded = np.zeros(np.concatenate([size, shape_arr[3:]]), dtype=data.dtype) exploded[::2, ::2, ::2] = data return exploded def expand_coordinates(indices): x, y, z = indices x[1::2, :, :] += 1 y[:, 1::2, :] += 1 z[:, :, 1::2] += 1 return x, y, z ax = make_ax() colors = np.array([[[&#39;#1f77b430&#39;]*3]*3]*3) colors[1,1,1] = &#39;#ff0000ff&#39; colors = explode(colors) filled = explode(np.ones((3, 3, 3))) x, y, z = expand_coordinates(np.indices(np.array(filled.shape) + 1)) ax.voxels(x, y, z, filled, facecolors=colors, edgecolors=&#39;gray&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax(True) ax.voxels(filled, edgecolors=&#39;gray&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax() ax.voxels(filled, facecolors=&#39;#1f77b430&#39;, edgecolors=&#39;gray&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax() ax.voxels(np.ones((3, 3, 3)), facecolors=&#39;#1f77b430&#39;, edgecolors=&#39;gray&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax() colors = np.array([[[&#39;#1f77b430&#39;]*3]*3]*3) colors[1,1,1] = &#39;#ff0000ff&#39; ax.voxels(np.ones((3, 3, 3)), facecolors=colors, edgecolor=&#39;gray&#39;) plt.show() import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def midpoints(x): sl = () for i in range(x.ndim): x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0 sl += np.index_exp[:] return x # prepare some coordinates, and attach rgb values to each r, g, b = np.indices((17, 17, 17)) / 16.0 rc = midpoints(r) gc = midpoints(g) bc = midpoints(b) # define a sphere about [0.5, 0.5, 0.5] sphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 &lt; 0.5**2 # combine the color components colors = np.zeros(sphere.shape + (3,)) colors[..., 0] = rc colors[..., 1] = gc colors[..., 2] = bc # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(r, g, b, sphere, facecolors=colors, edgecolors=np.clip(2*colors - 0.5, 0, 1), # brighter linewidth=0.5) ax.set(xlabel=&#39;r&#39;, ylabel=&#39;g&#39;, zlabel=&#39;b&#39;) plt.show() # https://matplotlib.org/gallery/mplot3d/voxels_numpy_logo.html import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def explode(data): size = np.array(data.shape)*2 data_e = np.zeros(size - 1, dtype=data.dtype) data_e[::2, ::2, ::2] = data return data_e # build up the numpy logo n_voxels = np.zeros((4, 3, 4), dtype=bool) n_voxels[0, 0, :] = True n_voxels[-1, 0, :] = True n_voxels[1, 0, 2] = True n_voxels[2, 0, 1] = True facecolors = np.where(n_voxels, &#39;#FFD65DC0&#39;, &#39;#7A88CCC0&#39;) edgecolors = np.where(n_voxels, &#39;#BFAB6E&#39;, &#39;#7D84A6&#39;) filled = np.ones(n_voxels.shape) # upscale the above voxel image, leaving gaps filled_2 = explode(filled) fcolors_2 = explode(facecolors) ecolors_2 = explode(edgecolors) # Shrink the gaps x, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2 x[0::2, :, :] += 0.05 y[:, 0::2, :] += 0.05 z[:, :, 0::2] += 0.05 x[1::2, :, :] += 0.95 y[:, 1::2, :] += 0.95 z[:, :, 1::2] += 0.95 fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2) plt.show() # https://stackoverflow.com/a/49281004/5270873 from mpl_toolkits.mplot3d import Axes3D from mpl_toolkits.mplot3d.art3d import Poly3DCollection import numpy as np import matplotlib.pyplot as plt def cuboid_data2(o, size=(1,1,1)): X = [[[0, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]], [[0, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 0]], [[1, 0, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]], [[0, 0, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1]], [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]], [[0, 1, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1]]] X = np.array(X).astype(float) for i in range(3): X[:,:,i] *= size[i] X += np.array(o) return X def plotCubeAt2(positions,sizes=None,colors=None, **kwargs): if not isinstance(colors,(list,np.ndarray)): colors=[&quot;C0&quot;]*len(positions) if not isinstance(sizes,(list,np.ndarray)): sizes=[(1,1,1)]*len(positions) g = [] for p,s,c in zip(positions,sizes,colors): g.append( cuboid_data2(p, size=s) ) return Poly3DCollection(np.concatenate(g), facecolors=np.repeat(colors,6), **kwargs) positions = [(-3,5,-2),(1,7,1)] sizes = [(4,5,3), (3,3,7)] colors = [&quot;crimson&quot;,&quot;limegreen&quot;] fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_aspect(&#39;equal&#39;) pc = plotCubeAt2(positions,sizes,colors=colors, edgecolor=&quot;k&quot;) ax.add_collection3d(pc) ax.set_xlim([-4,6]) ax.set_ylim([4,13]) ax.set_zlim([-3,9]) plt.show() "],["seaborn.html", "Ch. 7 Seaborn", " Ch. 7 Seaborn library(reticulate) use_condaenv(&quot;r-python&quot;, required = TRUE) # https://seaborn.pydata.org/examples/errorband_lineplots.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;darkgrid&quot;) # Load an example dataset with long-form data fmri = sns.load_dataset(&quot;fmri&quot;) # Plot the responses for different events and regions sns.lineplot(x=&quot;timepoint&quot;, y=&quot;signal&quot;, hue=&quot;region&quot;, style=&quot;event&quot;, data=fmri) plt.show() # https://seaborn.pydata.org/examples/horizontal_boxplot.html import seaborn as sns import matplotlib.pyplot as plt sns.set_theme(style=&quot;ticks&quot;) # Initialize the figure with a logarithmic x axis f, ax = plt.subplots(figsize=(7, 6)) ax.set_xscale(&quot;log&quot;) # Load the example planets dataset planets = sns.load_dataset(&quot;planets&quot;) # Plot the orbital period with horizontal boxes sns.boxplot(x=&quot;distance&quot;, y=&quot;method&quot;, data=planets, whis=[0, 100], width=.6, palette=&quot;vlag&quot;) # Add in points to show each observation sns.stripplot(x=&quot;distance&quot;, y=&quot;method&quot;, data=planets, size=4, color=&quot;.3&quot;, linewidth=0) # Tweak the visual presentation ax.xaxis.grid(True) ax.set(ylabel=&quot;&quot;) sns.despine(trim=True, left=True) plt.show() # https://seaborn.pydata.org/examples/timeseries_facets.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;dark&quot;) flights = sns.load_dataset(&quot;flights&quot;) # Plot each year&#39;s time series in its own facet g = sns.relplot( data=flights, x=&quot;month&quot;, y=&quot;passengers&quot;, col=&quot;year&quot;, hue=&quot;year&quot;, kind=&quot;line&quot;, palette=&quot;crest&quot;, linewidth=4, zorder=5, col_wrap=3, height=2, aspect=1.5, legend=False, ) # Iterate over each subplot to customize further for year, ax in g.axes_dict.items(): # Add the title as an annotation within the plot ax.text(.8, .85, year, transform=ax.transAxes, fontweight=&quot;bold&quot;) # Plot every year&#39;s time series in the background sns.lineplot( data=flights, x=&quot;month&quot;, y=&quot;passengers&quot;, units=&quot;year&quot;, estimator=None, color=&quot;.7&quot;, linewidth=1, ax=ax, ) # Reduce the frequency of the x axis ticks ax.set_xticks(ax.get_xticks()[::2]) # Tweak the supporting aspects of the plot g.set_titles(&quot;&quot;) g.set_axis_labels(&quot;&quot;, &quot;Passengers&quot;) g.tight_layout() plt.show() from __future__ import print_function, division import matplotlib.pyplot as plt import numpy as np import pandas as pd x = np.linspace(0, 10, 1000) plt.style.use(&#39;ggplot&#39;) plt.plot(x, np.sin(x), x, np.cos(x)); plt.show() # https://seaborn.pydata.org/examples/scatterplot_matrix.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;ticks&quot;) df = sns.load_dataset(&quot;penguins&quot;) sns.pairplot(df, hue=&quot;species&quot;) plt.show() import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;darkgrid&quot;) tips = sns.load_dataset(&quot;tips&quot;) fmri = sns.load_dataset(&quot;fmri&quot;) sns.relplot(x=&quot;timepoint&quot;, y=&quot;signal&quot;, hue=&quot;event&quot;, style=&quot;event&quot;, col=&quot;subject&quot;, col_wrap=5, height=3, aspect=.75, linewidth=2.5, kind=&quot;line&quot;, data=fmri.query(&quot;region == &#39;frontal&#39;&quot;)); plt.show() "],["advanced.html", "Ch. 8 Advanced 8.1 Adding labels 8.2 Change of axes", " Ch. 8 Advanced library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 8.1 Adding labels \\(r&#39;s(t) = \\mathcal{A}\\/\\sin(2 \\omega t)&#39;\\) \\(\\mathbb{blackboard}\\) import matplotlib.pyplot as plt import numpy as np mu, sigma = 100, 15 x = mu + sigma * np.random.randn(10000) # the histogram of the data n, bins, patches = plt.hist(x, 50, density=1, facecolor=&#39;g&#39;, alpha=0.75) plt.xlabel(&#39;Smarts&#39;) plt.ylabel(&#39;Probability&#39;) plt.title(&#39;Histogram of IQ&#39;) plt.text(60, .025, r&#39;$\\mu=100,\\ \\sigma=15$&#39;) plt.axis([40, 160, 0, 0.03]) plt.grid(True) plt.show() # https://matplotlib.org/gallery/subplots_axes_and_figures/subplots_adjust.html#sphx-glr-gallery-subplots-axes-and-figures-subplots-adjust-py import matplotlib.pyplot as plt import numpy as np # Fixing random state for reproducibility np.random.seed(19680801) plt.subplot(211) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplot(212) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplots_adjust(bottom=0.1, right=0.8, top=0.9) cax = plt.axes([0.85, 0.1, 0.075, 0.8]) plt.colorbar(cax=cax) plt.show() # https://matplotlib.org/gallery/text_labels_and_annotations/figlegend_demo.html#sphx-glr-gallery-text-labels-and-annotations-figlegend-demo-py import numpy as np import matplotlib.pyplot as plt fig, axs = plt.subplots(1, 2) x = np.arange(0.0, 2.0, 0.02) y1 = np.sin(2 * np.pi * x) y2 = np.exp(-x) l1, l2 = axs[0].plot(x, y1, &#39;rs-&#39;, x, y2, &#39;go&#39;) y3 = np.sin(4 * np.pi * x) y4 = np.exp(-2 * x) l3, l4 = axs[1].plot(x, y3, &#39;yd-&#39;, x, y4, &#39;k^&#39;) fig.legend((l1, l2), (&#39;Line 1&#39;, &#39;Line 2&#39;), &#39;upper left&#39;) fig.legend((l3, l4), (&#39;Line 3&#39;, &#39;Line 4&#39;), &#39;upper right&#39;) plt.tight_layout() plt.show() names = [&#39;group_a&#39;, &#39;group_b&#39;, &#39;group_c&#39;] values = [1, 10, 100] plt.figure(figsize=(9, 3)) plt.subplot(131) plt.bar(names, values) plt.subplot(132) plt.scatter(names, values) plt.subplot(133) plt.plot(names, values) plt.suptitle(&#39;Categorical Plotting&#39;) plt.show() # https://www.python-course.eu/matplotlib_multiple_figures.php import matplotlib.gridspec as gridspec import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(6, 4)) G = gridspec.GridSpec(3, 3) X = np.linspace(0, 2 * np.pi, 50, endpoint=True) F1 = 2.8 * np.cos(X) F2 = 5 * np.sin(X) F3 = 0.3 * np.sin(X) axes_1 = plt.subplot(G[0, :]) axes_1.plot(X, F1, &#39;r-&#39;, X, F2) axes_2 = plt.subplot(G[1, :-1]) axes_2.plot(X, F3) axes_3 = plt.subplot(G[1:, -1]) axes_3.plot([1,2,3,4], [1,10,100,1000], &#39;b-&#39;) axes_4 = plt.subplot(G[-1, 0]) axes_4.plot([1,2,3,4], [47, 11, 42, 60], &#39;r-&#39;) axes_5 = plt.subplot(G[-1, -2]) axes_5.plot([1,2,3,4], [7, 5, 4, 3.8]) plt.tight_layout() plt.show() # https://matplotlib.org/gallery/text_labels_and_annotations/figlegend_demo.html#sphx-glr-gallery-text-labels-and-annotations-figlegend-demo-py import numpy as np import matplotlib.pyplot as plt fig, axs = plt.subplots(1, 2) x = np.arange(0.0, 2.0, 0.02) y1 = np.sin(2 * np.pi * x) y2 = np.exp(-x) l1, l2 = axs[0].plot(x, y1, &#39;rs-&#39;, x, y2, &#39;go&#39;) y3 = np.sin(4 * np.pi * x) y4 = np.exp(-2 * x) l3, l4 = axs[1].plot(x, y3, &#39;yd-&#39;, x, y4, &#39;k^&#39;) fig.legend((l1, l2), (&#39;Line 1&#39;, &#39;Line 2&#39;), &#39;upper left&#39;) fig.legend((l3, l4), (&#39;Line 3&#39;, &#39;Line 4&#39;), &#39;upper right&#39;) plt.tight_layout() plt.show() 8.2 Change of axes # Fixing random state for reproducibility np.random.seed(19680801) # make up some data in the open interval (0, 1) y = np.random.normal(loc=0.5, scale=0.4, size=1000) y = y[(y &gt; 0) &amp; (y &lt; 1)] y.sort() x = np.arange(len(y)) # plot with various axes scales plt.figure() # linear plt.subplot(221) plt.plot(x, y) plt.yscale(&#39;linear&#39;) plt.title(&#39;linear&#39;) plt.grid(True) # log plt.subplot(222) plt.plot(x, y) plt.yscale(&#39;log&#39;) plt.title(&#39;log&#39;) plt.grid(True) # symmetric log plt.subplot(223) plt.plot(x, y - y.mean()) plt.yscale(&#39;symlog&#39;, linthresh=0.01) plt.title(&#39;symlog&#39;) plt.grid(True) # logit plt.subplot(224) plt.plot(x, y) plt.yscale(&#39;logit&#39;) plt.title(&#39;logit&#39;) plt.grid(True) # Adjust the subplot layout, because the logit one may take more space # than usual, due to y-tick labels like &quot;1 - 10^{-3}&quot; plt.subplots_adjust(top=0.92, bottom=0.08, left=0.10, right=0.95, hspace=0.25, wspace=0.35) plt.show() # https://matplotlib.org/gallery/subplots_axes_and_figures/subplots_adjust.html#sphx-glr-gallery-subplots-axes-and-figures-subplots-adjust-py import matplotlib.pyplot as plt import numpy as np # Fixing random state for reproducibility np.random.seed(19680801) plt.subplot(211) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplot(212) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplots_adjust(bottom=0.1, right=0.8, top=0.9) cax = plt.axes([0.85, 0.1, 0.075, 0.8]) plt.colorbar(cax=cax) plt.show() # step demo # https://matplotlib.org/gallery/lines_bars_and_markers/step_demo.html#sphx-glr-gallery-lines-bars-and-markers-step-demo-py import numpy as np from numpy import ma import matplotlib.pyplot as plt x = np.arange(1, 7, 0.4) y0 = np.sin(x) y = y0.copy() + 2.5 plt.step(x, y, label=&#39;pre (default)&#39;) y -= 0.5 plt.step(x, y, where=&#39;mid&#39;, label=&#39;mid&#39;) y -= 0.5 plt.step(x, y, where=&#39;post&#39;, label=&#39;post&#39;) y = ma.masked_where((y0 &gt; -0.15) &amp; (y0 &lt; 0.15), y - 0.5) plt.step(x, y, label=&#39;masked (pre)&#39;) plt.legend() plt.xlim(0, 7) plt.ylim(-0.5, 4) plt.show() "]]
