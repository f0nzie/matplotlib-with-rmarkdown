[["index.html", "Matplotlib with Rmarkdown Preface Method", " Matplotlib with Rmarkdown Alfonso R. Reyes 2020-11-04 Preface The goal of r-test-matplotlib is thoroughly testing that Python matplotlib works seamlessly from within RStudio. Making matplotlib run from within RStudio using the R package reticulate and Python Anaconda has improved a lot in the past few months. The package reticulate and RStudio have gone through a thorough transformation. Enough to say that it’s an accepted fact that Python and R have to get along for the benefit of data science, machine learning and artificial intelligence. Method R engine Since I combine code from different sources (R, Python, and Bash), I have added some colorization to the code chunks when I use a code engine. Here is an example of using the R engine. {-=\"\"} R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) What we are doing is calling the R package reticulate, which makes possible the communication between Python and R. The way you will enter this block of code is pretty straightforward; you just indicate the engine you want, in this, case r, like this: ```{r} library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) ``` There is even a shortcut in RStudio to add the R block automatically for you: Ctrl Alt I. Bash engine This chunk of code with the engine set to bash will list all the conda environments installed and available to the user (in my machine): Shell echo &quot;list all conda environments available&quot; source ~/anaconda3/etc/profile.d/conda.sh conda activate r-python conda env list echo &quot;working from the terminal&quot; #:&gt; list all conda environments available #:&gt; # conda environments: #:&gt; # #:&gt; base /home/msfz751/anaconda3 #:&gt; man_ccia /home/msfz751/anaconda3/envs/man_ccia #:&gt; porepy /home/msfz751/anaconda3/envs/porepy #:&gt; python_book /home/msfz751/anaconda3/envs/python_book #:&gt; r-python * /home/msfz751/anaconda3/envs/r-python #:&gt; r-tensorflow /home/msfz751/anaconda3/envs/r-tensorflow #:&gt; r-toarchboard /home/msfz751/anaconda3/envs/r-toarchboard #:&gt; r-torch /home/msfz751/anaconda3/envs/r-torch #:&gt; #:&gt; working from the terminal To set the block as bash, we enter it like this: ```{bash} echo &quot;list all conda environments available&quot; source ~/anaconda3/etc/profile.d/conda.sh conda activate r-python conda env list echo &quot;working from the terminal&quot; ``` And the block will execute your commands as you were in the terminal. Python engine This other colorized chunk of code shows a simple example of the use of matplotlib from with R. It is a very simple example but now you now the color convention for different sets of code I will be using in this minimal book. Python import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4]) plt.ylabel(&#39;some numbers&#39;) plt.show() As you may be expecting it follows the same pattern when we want to use a Python engine. You just have to indicate it after three backticks, curly brace opened, python, and a curly brace closed: ```{python}. You end the Python block with other three backticks. That’s it. ```{python} import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4]) plt.ylabel(&#39;some numbers&#39;) plt.show() ``` "],["introduction.html", "Ch. 1 Introduction 1.1 “Hello world” 1.2 The parts of a plot 1.3 Can do business plots too 1.4 And real time 1.5 And also 3D", " Ch. 1 Introduction R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 1.1 “Hello world” Python import matplotlib.pyplot as plt import numpy as np t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2*np.pi*t) plt.plot(t, s) plt.xlabel(&#39;time (s)&#39;) plt.ylabel(&#39;voltage (mV)&#39;) plt.title(&#39;About as simple as it gets, folks&#39;) plt.grid(True) plt.savefig(&quot;test.png&quot;) plt.show() 1.2 The parts of a plot I love this plot because it will help to formulate the right question when you are looking for online assistance. Sooner of later you will be in need to customize the \\(x\\) or \\(y\\) axis ticks in such a way that present specific data points and skip the defaults. Or, get rid of so many x axis labels that superimposing one to each other. Python # https://matplotlib.org/gallery/showcase/anatomy.html#sphx-glr-gallery-showcase-anatomy-py import numpy as np import matplotlib.pyplot as plt from matplotlib.ticker import AutoMinorLocator, MultipleLocator, FuncFormatter np.random.seed(19680801) X = np.linspace(0.5, 3.5, 100) Y1 = 3+np.cos(X) Y2 = 1+np.cos(1+X/0.75)/2 Y3 = np.random.uniform(Y1, Y2, len(X)) fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(1, 1, 1, aspect=1) def minor_tick(x, pos): if not x % 1.0: return &quot;&quot; return &quot;%.2f&quot; % x ax.xaxis.set_major_locator(MultipleLocator(1.000)) ax.xaxis.set_minor_locator(AutoMinorLocator(4)) ax.yaxis.set_major_locator(MultipleLocator(1.000)) ax.yaxis.set_minor_locator(AutoMinorLocator(4)) ax.xaxis.set_minor_formatter(FuncFormatter(minor_tick)) ax.set_xlim(0, 4) #:&gt; (0.0, 4.0) ax.set_ylim(0, 4) #:&gt; (0.0, 4.0) ax.tick_params(which=&#39;major&#39;, width=1.0) ax.tick_params(which=&#39;major&#39;, length=10) ax.tick_params(which=&#39;minor&#39;, width=1.0, labelsize=10) ax.tick_params(which=&#39;minor&#39;, length=5, labelsize=10, labelcolor=&#39;0.25&#39;) ax.grid(linestyle=&quot;--&quot;, linewidth=0.5, color=&#39;.25&#39;, zorder=-10) ax.plot(X, Y1, c=(0.25, 0.25, 1.00), lw=2, label=&quot;Blue signal&quot;, zorder=10) ax.plot(X, Y2, c=(1.00, 0.25, 0.25), lw=2, label=&quot;Red signal&quot;) ax.plot(X, Y3, linewidth=0, marker=&#39;o&#39;, markerfacecolor=&#39;w&#39;, markeredgecolor=&#39;k&#39;) ax.set_title(&quot;Anatomy of a figure&quot;, fontsize=20, verticalalignment=&#39;bottom&#39;) ax.set_xlabel(&quot;X axis label&quot;) ax.set_ylabel(&quot;Y axis label&quot;) ax.legend() def circle(x, y, radius=0.15): from matplotlib.patches import Circle from matplotlib.patheffects import withStroke circle = Circle((x, y), radius, clip_on=False, zorder=10, linewidth=1, edgecolor=&#39;black&#39;, facecolor=(0, 0, 0, .0125), path_effects=[withStroke(linewidth=5, foreground=&#39;w&#39;)]) ax.add_artist(circle) def text(x, y, text): ax.text(x, y, text, backgroundcolor=&quot;white&quot;, ha=&#39;center&#39;, va=&#39;top&#39;, weight=&#39;bold&#39;, color=&#39;blue&#39;) # Minor tick circle(0.50, -0.10) text(0.50, -0.32, &quot;Minor tick label&quot;) # Major tick circle(-0.03, 4.00) text(0.03, 3.80, &quot;Major tick&quot;) # Minor tick circle(0.00, 3.50) text(0.00, 3.30, &quot;Minor tick&quot;) # Major tick label circle(-0.15, 3.00) text(-0.15, 2.80, &quot;Major tick label&quot;) # X Label circle(1.80, -0.27) text(1.80, -0.45, &quot;X axis label&quot;) # Y Label circle(-0.27, 1.80) text(-0.27, 1.6, &quot;Y axis label&quot;) # Title circle(1.60, 4.13) text(1.60, 3.93, &quot;Title&quot;) # Blue plot circle(1.75, 2.80) text(1.75, 2.60, &quot;Line\\n(line plot)&quot;) # Red plot circle(1.20, 0.60) text(1.20, 0.40, &quot;Line\\n(line plot)&quot;) # Scatter plot circle(3.20, 1.75) text(3.20, 1.55, &quot;Markers\\n(scatter plot)&quot;) # Grid circle(3.00, 3.00) text(3.00, 2.80, &quot;Grid&quot;) # Legend circle(3.70, 3.80) text(3.70, 3.60, &quot;Legend&quot;) # Axes circle(0.5, 0.5) text(0.5, 0.3, &quot;Axes&quot;) # Figure circle(-0.3, 0.65) text(-0.3, 0.45, &quot;Figure&quot;) color = &#39;blue&#39; ax.annotate(&#39;Spines&#39;, xy=(4.0, 0.35), xycoords=&#39;data&#39;, xytext=(3.3, 0.5), textcoords=&#39;data&#39;, weight=&#39;bold&#39;, color=color, arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3&quot;, color=color)) ax.annotate(&#39;&#39;, xy=(3.15, 0.0), xycoords=&#39;data&#39;, xytext=(3.45, 0.45), textcoords=&#39;data&#39;, weight=&#39;bold&#39;, color=color, arrowprops=dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3&quot;, color=color)) ax.text(4.0, -0.4, &quot;Made with http://matplotlib.org&quot;, fontsize=10, ha=&quot;right&quot;, color=&#39;.5&#39;) plt.show() 1.3 Can do business plots too Python import numpy as np import matplotlib.pyplot as plt plt.style.use(&#39;ggplot&#39;) fig, axes = plt.subplots(ncols=2, nrows=2) ax1, ax2, ax3, ax4 = axes.ravel() # scatter plot (Note: `plt.scatter` doesn&#39;t use default colors) x, y = np.random.normal(size=(2, 200)) ax1.plot(x, y, &#39;o&#39;) # sinusoidal lines with colors from default color cycle L = 2*np.pi x = np.linspace(0, L) ncolors = len(plt.rcParams[&#39;axes.prop_cycle&#39;]) shift = np.linspace(0, L, ncolors, endpoint=False) for s in shift: ax2.plot(x, np.sin(x + s), &#39;-&#39;) ax2.margins(0) # bar graphs x = np.arange(5) y1, y2 = np.random.randint(1, 25, size=(2, 5)) width = 0.25 ax3.bar(x, y1, width) ax3.bar(x + width, y2, width, color=list(plt.rcParams[&#39;axes.prop_cycle&#39;])[2][&#39;color&#39;]) ax3.set_xticks(x + width) ax3.set_xticklabels([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]) # circles with colors from default color cycle for i, color in enumerate(plt.rcParams[&#39;axes.prop_cycle&#39;]): xy = np.random.normal(size=2) ax4.add_patch(plt.Circle(xy, radius=0.3, color=color[&#39;color&#39;])) ax4.axis(&#39;equal&#39;) ax4.margins(0) plt.show() 1.4 And real time Python # https://matplotlib.org/gallery/lines_bars_and_markers/cohere.html#sphx-glr-gallery-lines-bars-and-markers-cohere-py import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) dt = 0.01 t = np.arange(0, 30, dt) nse1 = np.random.randn(len(t)) # white noise 1 nse2 = np.random.randn(len(t)) # white noise 2 # Two signals with a coherent part at 10Hz and a random part s1 = np.sin(2 * np.pi * 10 * t) + nse1 s2 = np.sin(2 * np.pi * 10 * t) + nse2 fig, axs = plt.subplots(2, 1) axs[0].plot(t, s1, t, s2) axs[0].set_xlim(0, 2) axs[0].set_xlabel(&#39;time&#39;) axs[0].set_ylabel(&#39;s1 and s2&#39;) axs[0].grid(True) cxy, f = axs[1].cohere(s1, s2, 256, 1. / dt) axs[1].set_ylabel(&#39;coherence&#39;) fig.tight_layout() plt.show() 1.5 And also 3D Although in data science 3D plots are not recommended, if there is a compelling case where the 3D plot could explain it better than a 2D plot, then, it should be okay. But the rule is do not abuse of 3D. What you are trying to convey is information per square centimeter of graphics. Python # https://matplotlib.org/2.0.2/examples/mplot3d/contour3d_demo.html from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) cset = ax.contour(X, Y, Z, cmap=cm.coolwarm) ax.clabel(cset, fontsize=9, inline=1) plt.show() "],["python-environments.html", "Ch. 2 Python environments 2.1 Why virtual environments? 2.2 Python virtual environment and R 2.3 conda environments 2.4 Running Python from R 2.5 A plot demo", " Ch. 2 Python environments 2.1 Why virtual environments? There are several ways of running Python code. In this minimal book, we will see two of them: conda environments, and GNU Python virtualenv Both work similarly in the sense of providing an isolated, fresh Python environment with selected packages, without much interference of the existing Python in the operating system. Virtual environments, docker containers, and virtual machines are few of the several ways of virtualizing Python environments. This all in pursue of reproducibility, or a workspace that could replicate the same results of previous analysis without the issues provoked by missing dependencies, libraries, or the operating own system environment variables. 2.2 Python virtual environment and R Although, it is not absolutely necessary to create a virtual environment to run Rmarkdown Python notebooks, it is highly recommended because you will be able to run a selected analysis, over and over, without paying too much attention to updates or upgrades in the hosting operating system. This means that you could freeze in time a virtual environment, without disturbing it with software updates. This virtual environment should be able to be re-created from a text file with a minimum set of instructions, or a list of packages, or recipe, that bring a fresh Python environment, few months from now. Both, methods of creating Python virtual environments, conda and virtualenv use a text file with a recipe to do just that. In conda there is the file environment.yml. In virtualenv, that file is named requirements.txt. But you could use any name you want. These names are just standard, and if you find them them in a repository, it mean less pain in reproducing the experiment. 2.3 conda environments They require the installation of the Anaconda3 platform, which is pretty straight forward for all operating systems. If you want want to create a conda virtual environment, then, you will have many ways of doing it: 2.3.1 environment with Python version specified In this example, conda will build an environment using the Python version 3.7. If the version is not specified, conda will install the default. Shell conda create --name python_env python=3.7 2.3.2 specify Python version and list package names Here, we leave conda to find a suitable combination of package versions to build this environment. Shell conda create --name python_book python=3.7 pandas numpy scipy scikit-learn nltk matplotlib seaborn plotnine ipython lxml -y The last option -y means that it will install without asking yes or no. 2.3.3 specify Python version and version for the packages This recipe is more strict. You are looking for a precise package versions, which you know worked, and run without conflicts or bugs. Shell conda create -n plot_env python=3.7 numpy=1.19 matplotlib=3.3 pandas=1.1 seaborn=0.11 2.4 Running Python from R Load the reticulate library. R library(reticulate) Load the Python environment R use_condaenv(&quot;r-python&quot;) Environments available and current settings R py_config() #:&gt; python: /home/msfz751/anaconda3/envs/r-python/bin/python #:&gt; libpython: /home/msfz751/anaconda3/envs/r-python/lib/libpython3.7m.so #:&gt; pythonhome: /home/msfz751/anaconda3/envs/r-python:/home/msfz751/anaconda3/envs/r-python #:&gt; version: 3.7.8 | packaged by conda-forge | (default, Jul 31 2020, 02:25:08) [GCC 7.5.0] #:&gt; numpy: /home/msfz751/anaconda3/envs/r-python/lib/python3.7/site-packages/numpy #:&gt; numpy_version: 1.19.2 #:&gt; #:&gt; python versions found: #:&gt; /home/msfz751/anaconda3/envs/r-python/bin/python #:&gt; /usr/bin/python3 #:&gt; /usr/bin/python #:&gt; /home/msfz751/anaconda3/bin/python #:&gt; /home/msfz751/anaconda3/envs/man_ccia/bin/python #:&gt; /home/msfz751/anaconda3/envs/porepy/bin/python #:&gt; /home/msfz751/anaconda3/envs/python_book/bin/python #:&gt; /home/msfz751/anaconda3/envs/r-tensorflow/bin/python #:&gt; /home/msfz751/anaconda3/envs/r-toarchboard/bin/python #:&gt; /home/msfz751/anaconda3/envs/r-torch/bin/python Ask if Python is available to R: R reticulate::py_available() #:&gt; [1] TRUE 2.5 A plot demo Once the environment is loaded, then our Python code chunks will just run: Python # https://github.com/bendichter/brokenaxes import matplotlib import matplotlib.pyplot as plt import numpy as np import matplotlib.pyplot as plt from brokenaxes import brokenaxes import numpy as np fig = plt.figure(figsize=(5,5)) bax = brokenaxes(xlims=((1, 500), (600, 10000)), ylims=((1, 500), (600, 10000)), hspace=.15, xscale=&#39;log&#39;, yscale=&#39;log&#39;) x = np.logspace(0.0, 4, 100) bax.loglog(x, x, label=&#39;$y=x=10^{0}$ to $10^{4}$&#39;) bax.legend(loc=&#39;best&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;major&#39;, ls=&#39;-&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;minor&#39;, ls=&#39;--&#39;, alpha=0.4) bax.set_xlabel(&#39;x&#39;) bax.set_ylabel(&#39;y&#39;) plt.show() The code, you would have to type, would look like this: ```{python} import matplotlib import matplotlib.pyplot as plt import numpy as np import matplotlib.pyplot as plt from brokenaxes import brokenaxes import numpy as np fig = plt.figure(figsize=(5,5)) bax = brokenaxes(xlims=((1, 500), (600, 10000)), ylims=((1, 500), (600, 10000)), hspace=.15, xscale=&#39;log&#39;, yscale=&#39;log&#39;) x = np.logspace(0.0, 4, 100) bax.loglog(x, x, label=&#39;\\$y=x=10\\^{0}\\$ to \\$10\\^{4}\\$&#39;) bax.legend(loc=&#39;best&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;major&#39;, ls=&#39;-&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;minor&#39;, ls=&#39;--&#39;, alpha=0.4) bax.set_xlabel(&#39;x&#39;) bax.set_ylabel(&#39;y&#39;) plt.show() ``` Remember. You open a Python block in Rmarkdown with ```{python} and close it with: ``` "],["sharing-data-objects.html", "Ch. 3 Sharing data objects 3.1 From R to Python, back to R 3.2 From Python to R, back to Python", " Ch. 3 Sharing data objects 3.1 From R to Python, back to R Always load the Python environment with the packages you need. R library(reticulate) use_condaenv(&quot;r-python&quot;) Load the dataset in R and assign it to an R object. Let’s call it autos: R # R chunk autos = cars # assign cars to autos Read the R object from Python by adding the prefix r. before the name of the R object autos. Then, assign it to a Python object that we will name autos_py. Python # Python chunk import numpy import pandas autos_py = r.autos Make a calculation between two columns in the dataset (distance and speed), and assign it to a new column in the dataset with autos_py['time']. Python # Python chunk autos_py[&#39;time&#39;] = autos_py[&#39;dist&#39;] / autos_py[&#39;speed&#39;] From R, read the Python object py$autos_py and plot the dataset with the new column time, that you obtained in Python. Observe that we added the prefix py$ in front of the Python object autos_py: R # R chunk plot(py$autos_py) 3.2 From Python to R, back to Python "],["math.html", "Ch. 4 Math 4.1 Functions 4.2 Functions with Latex labels 4.3 Multiple functions in the same plot 4.4 Overlapping functions 4.5 Surface functions 4.6 3D wireframe 4.7 3D contour plot 4.8 Machine Learning", " Ch. 4 Math R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 4.1 Functions Python # https://www.geeksforgeeks.org/plot-mathematical-expressions-in-python-using-matplotlib/ # Import libraries import matplotlib.pyplot as plt import numpy as np x = np.linspace(-6, 6, 50) fig = plt.figure(figsize = (14, 8)) # Plot y = cos(x) y = np.cos(x) plt.plot(x, y, &#39;b&#39;, label =&#39;cos(x)&#39;) # Plot degree 2 Taylor polynomial y2 = 1 - x**2 / 2 plt.plot(x, y2, &#39;r-.&#39;, label =&#39;Degree 2&#39;) # Plot degree 4 Taylor polynomial y4 = 1 - x**2 / 2 + x**4 / 24 plt.plot(x, y4, &#39;g:&#39;, label =&#39;Degree 4&#39;) # Add features to our figure plt.legend() plt.grid(True, linestyle =&#39;:&#39;) plt.xlim([-6, 6]) plt.ylim([-4, 4]) plt.title(&#39;Taylor Polynomials of cos(x) at x = 0&#39;) plt.xlabel(&#39;x-axis&#39;) plt.ylabel(&#39;y-axis&#39;) # Show plot plt.show() 4.2 Functions with Latex labels Python # https://www.kaggle.com/sskiing/matplotlib-showcase-examples import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Polygon def func(x): return (x - 3) * (x - 5) * (x - 7) + 85 a, b = 2, 9 # integral limits x = np.linspace(0, 10) y = func(x) fig, ax = plt.subplots(dpi=200) plt.plot(x, y, &#39;r&#39;, linewidth=2) plt.ylim(ymin=0) # Make the shaded region ix = np.linspace(a, b) iy = func(ix) verts = [(a, 0)] + list(zip(ix, iy)) + [(b, 0)] poly = Polygon(verts, facecolor=&#39;0.9&#39;, edgecolor=&#39;0.5&#39;) ax.add_patch(poly) plt.text(0.5 * (a + b), 30, r&quot;$\\int_a^b f(x)\\mathrm{d}x$&quot;, horizontalalignment=&#39;center&#39;, fontsize=20) plt.figtext(0.9, 0.05, &#39;$x$&#39;) plt.figtext(0.1, 0.9, &#39;$y$&#39;) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.set_xticks((a, b)) ax.set_xticklabels((&#39;$a$&#39;, &#39;$b$&#39;)) ax.set_yticks([]) plt.show() 4.3 Multiple functions in the same plot Python import matplotlib.pyplot as plt import numpy as np t = np.arange(0.0, 2.0, 0.01) s1 = np.sin(2 * np.pi * t) s2 = np.exp(-t) s3 = s1 * s2 fig, axs = plt.subplots(3, 1, sharex=True) # Remove horizontal space between axes fig.subplots_adjust(hspace=0) # Plot each graph, and manually set the y tick values axs[0].plot(t, s1) axs[0].set_yticks(np.arange(-0.9, 1.0, 0.4)) axs[0].set_ylim(-1, 1) axs[1].plot(t, s2) axs[1].set_yticks(np.arange(0.1, 1.0, 0.2)) axs[1].set_ylim(0, 1) axs[2].plot(t, s3) axs[2].set_yticks(np.arange(-0.9, 1.0, 0.4)) axs[2].set_ylim(-1, 1) plt.show() 4.4 Overlapping functions We use subplot to arrange the two functions. Observe that the y-axis is the same in both functions. Python # https://www.python-course.eu/matplotlib_multiple_figures.php import numpy as np import matplotlib.pyplot as plt def f(t): return np.exp(-t) * np.cos(2*np.pi*t) def g(t): return np.sin(t) * np.cos(1/(t+0.1)) t1 = np.arange(0.0, 5.0, 0.1) t2 = np.arange(0.0, 5.0, 0.02) plt.subplot(212) plt.plot(t1, g(t1), &#39;ro&#39;, t2, f(t2), &#39;k&#39;) plt.grid(color=&#39;b&#39;, alpha=0.5, linestyle=&#39;dashed&#39;, linewidth=0.5) plt.show() 4.5 Surface functions Python # http://www.scipy-lectures.org/intro/matplotlib/auto_examples/plot_plot3d_ex.html import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = Axes3D(fig) X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X ** 2 + Y ** 2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.hot) ax.contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-2, cmap=plt.cm.hot) ax.set_zlim(-2, 2) plt.show() Python # https://matplotlib.org/gallery/mplot3d/offset.html#sphx-glr-gallery-mplot3d-offset-py # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) X, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25] Z = np.sqrt(np.abs(np.cos(X) + np.cos(Y))) ax.plot_surface(X + 1e5, Y + 1e5, Z, cmap=&#39;autumn&#39;, cstride=2, rstride=2) ax.set_xlabel(&quot;X label&quot;) ax.set_ylabel(&quot;Y label&quot;) ax.set_zlabel(&quot;Z label&quot;) ax.set_zlim(0, 2) plt.show() Python # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/surface3d_radial.py from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) # Create the mesh in polar coordinates and compute corresponding Z. r = np.linspace(0, 1.25, 50) p = np.linspace(0, 2*np.pi, 50) R, P = np.meshgrid(r, p) Z = ((R**2 - 1)**2) # Express the mesh in the cartesian system. X, Y = R*np.cos(P), R*np.sin(P) # Plot the surface. ax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r) # Tweak the limits and add latex math labels. ax.set_zlim(0, 1) ax.set_xlabel(r&#39;$\\phi_\\mathrm{real}$&#39;) ax.set_ylabel(r&#39;$\\phi_\\mathrm{im}$&#39;) ax.set_zlabel(r&#39;$V(\\phi)$&#39;) plt.show() 4.6 3D wireframe Python # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/wire3d.py from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) # Grab some test data. X, Y, Z = axes3d.get_test_data(0.05) # Plot a basic wireframe. ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10) plt.show() 4.7 3D contour plot Python # https://matplotlib.org/2.0.2/examples/mplot3d/contour3d_demo.html from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) cset = ax.contour(X, Y, Z, cmap=cm.coolwarm) ax.clabel(cset, fontsize=9, inline=1) plt.show() 4.8 Machine Learning Python import numpy as np from matplotlib import pyplot as plt from sklearn import neighbors, datasets from matplotlib.colors import ListedColormap # Create color maps for 3-class classification problem, as with iris cmap_light = ListedColormap([&#39;#FFAAAA&#39;,&#39;#AAFFAA&#39;,&#39;#AAAAFF&#39;]) cmap_bold = ListedColormap([&#39;#FF0000&#39;,&#39;#00FF00&#39;,&#39;#0000FF&#39;]) iris = datasets.load_iris() X = iris.data[:, :2] # we only take the first two features. We could # avoid this ugly slicing by using a two-dim dataset y = iris.target knn = neighbors.KNeighborsClassifier(n_neighbors=1) knn.fit(X, y) x_min, x_max = X[:, 0].min() - .1, X[:, 0].max() + .1 y_min, y_max = X[:, 1].min() - .1, X[:, 1].max() + .1 xx, yy = np.meshgrid(np.linspace(x_min, x_max, 100), np.linspace(y_min, y_max, 100)) Z = knn.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) plt.figure() plt.pcolormesh(xx, yy, Z, cmap=cmap_light) # Plot also the training points plt.scatter(X[:, 0], X[:, 1], c=y, cmap=cmap_bold) plt.xlabel(&#39;sepal length (cm)&#39;) plt.ylabel(&#39;sepal width (cm)&#39;) plt.axis(&#39;tight&#39;) plt.show() "],["scientific.html", "Ch. 5 Scientific 5.1 Solve Laplace 5.2 Eigenvalue problems 5.3 Computational Physics 5.4 Triangulation and Delauney maps 5.5 Contour maps 5.6 Real time 5.7 Density plots", " Ch. 5 Scientific R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 5.1 Solve Laplace # https://www.eidos.ic.i.u-tokyo.ac.jp/~tau/lecture/computational_physics/docs/computational_physics.pdf # Page # Solve Laplace equation from numpy import * import matplotlib.pylab as p; from mpl_toolkits.mplot3d import Axes3D print(&quot;Initializing&quot;) Nmax = 100; Niter = 70; V = zeros((Nmax, Nmax), float) # float maybe Float print(&quot;Working hard, wait for the figure while I count to 60&quot;) for k in range(0, Nmax-1): V[k,0] = 100.0 # line at 100V for iter in range(Niter): # iterations over algorithm if iter%10 == 0: print( iter) for i in range(1, Nmax-2): for j in range(1,Nmax-2): V[i,j] = 0.25 * (V[i+1,j] + V[i-1,j] + V[i,j+1] + V[i,j-1]) x = range(0, Nmax-1, 2); y = range(0, 50, 2) # plot every other point X, Y = p.meshgrid(x,y) def functz(V): # Function returns V(x, y) z = V[X,Y] return z Z = functz(V) fig = p.figure() # Create figures ax = Axes3D(fig) # plot axe ax.plot_wireframe(X, Y, Z, color = &#39;r&#39;) # red wireframe ax.set_xlabel(&#39;X&#39;) # label axes ax.set_ylabel(&#39;Y&#39;) ax.set_zlabel(&#39;Potential&#39;) p.show() # display fig, close shell to quit 5.2 Eigenvalue problems lobpcg (Locally Optimal Block Preconditioned Conjugate Gradient Method) * works very well in combination with PyAMG (example by Nathan Bell) Python # http://scipy-lectures.org/_downloads/ScipyLectures-simple.pdf # Page 348 # Compute eigenvectors and eigenvalues using a preconditioned eigensolver # ======================================================================== # # In this example Smoothed Aggregation (SA) is used to precondition # the LOBPCG eigensolver on a two-dimensional Poisson problem with # Dirichlet boundary conditions. import scipy from scipy.sparse.linalg import lobpcg import matplotlib.pyplot as plt from pyamg import smoothed_aggregation_solver from pyamg.gallery import poisson N = 100 K = 9 A = poisson((N,N), format=&#39;csr&#39;) # create the AMG hierarchy ml = smoothed_aggregation_solver(A) # initial approximation to the K eigenvectors X = scipy.rand(A.shape[0], K) # preconditioner based on ml M = ml.aspreconditioner() # compute eigenvalues and eigenvectors with LOBPCG W,V = lobpcg(A, X, M=M, tol=1e-8, largest=False) plt.figure(figsize=(9,9)) for i in range(K): plt.subplot(3, 3, i+1) plt.title(&#39;Eigenvector%d&#39;% i) plt.pcolor(V[:,i].reshape(N,N)) plt.axis(&#39;equal&#39;) plt.axis(&#39;off&#39;) plt.show() 5.3 Computational Physics Python # Plot of the Lorenz Attractor based on Edward Lorenz&#39;s 1963 &quot;Deterministic # Nonperiodic Flow&quot; publication. # http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2 import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorenz(x, y, z, s=10, r=28, b=2.667): x_dot = s*(y - x) y_dot = r*x - y - x*z z_dot = x*y - b*z return x_dot, y_dot, z_dot dt = 0.01 stepCnt = 10000 # Need one more for the initial values xs = np.empty((stepCnt + 1,)) ys = np.empty((stepCnt + 1,)) zs = np.empty((stepCnt + 1,)) # Setting initial values xs[0], ys[0], zs[0] = (0., 1., 1.05) # Stepping through &quot;time&quot;. for i in range(stepCnt): # Derivatives of the X, Y, Z state x_dot, y_dot, z_dot = lorenz(xs[i], ys[i], zs[i]) xs[i + 1] = xs[i] + (x_dot * dt) ys[i + 1] = ys[i] + (y_dot * dt) zs[i + 1] = zs[i] + (z_dot * dt) fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.plot(xs, ys, zs, lw=0.5) ax.set_xlabel(&quot;X Axis&quot;) ax.set_ylabel(&quot;Y Axis&quot;) ax.set_zlabel(&quot;Z Axis&quot;) ax.set_title(&quot;Lorenz Attractor&quot;) plt.show() Python # https://matplotlib.org/gallery/images_contours_and_fields/contour_image.html#sphx-glr-gallery-images-contours-and-fields-contour-image-py import matplotlib.pyplot as plt import numpy as np from matplotlib import cm # Default delta is large because that makes it fast, and it illustrates # the correct registration between image and contours. delta = 0.5 extent = (-3, 4, -4, 3) x = np.arange(-3.0, 4.001, delta) y = np.arange(-4.0, 3.001, delta) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 # Boost the upper limit to avoid truncation errors. levels = np.arange(-2.0, 1.601, 0.4) norm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max()) cmap = cm.PRGn fig, _axs = plt.subplots(nrows=2, ncols=2) fig.subplots_adjust(hspace=0.3) axs = _axs.flatten() cset1 = axs[0].contourf(X, Y, Z, levels, norm=norm, cmap=cm.get_cmap(cmap, len(levels) - 1)) # It is not necessary, but for the colormap, we need only the # number of levels minus 1. To avoid discretization error, use # either this number or a large number such as the default (256). # If we want lines as well as filled regions, we need to call # contour separately; don&#39;t try to change the edgecolor or edgewidth # of the polygons in the collections returned by contourf. # Use levels output from previous call to guarantee they are the same. cset2 = axs[0].contour(X, Y, Z, cset1.levels, colors=&#39;k&#39;) # We don&#39;t really need dashed contour lines to indicate negative # regions, so let&#39;s turn them off. for c in cset2.collections: c.set_linestyle(&#39;solid&#39;) # It is easier here to make a separate call to contour than # to set up an array of colors and linewidths. # We are making a thick green line as a zero contour. # Specify the zero level as a tuple with only 0 in it. cset3 = axs[0].contour(X, Y, Z, (0,), colors=&#39;g&#39;, linewidths=2) axs[0].set_title(&#39;Filled contours&#39;) fig.colorbar(cset1, ax=axs[0]) axs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm) axs[1].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;upper&#39;, extent=extent) axs[1].set_title(&quot;Image, origin &#39;upper&#39;&quot;) axs[2].imshow(Z, origin=&#39;lower&#39;, extent=extent, cmap=cmap, norm=norm) axs[2].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;lower&#39;, extent=extent) axs[2].set_title(&quot;Image, origin &#39;lower&#39;&quot;) # We will use the interpolation &quot;nearest&quot; here to show the actual # image pixels. # Note that the contour lines don&#39;t extend to the edge of the box. # This is intentional. The Z values are defined at the center of each # image pixel (each color block on the following subplot), so the # domain that is contoured does not extend beyond these pixel centers. im = axs[3].imshow(Z, interpolation=&#39;nearest&#39;, extent=extent, cmap=cmap, norm=norm) axs[3].contour(Z, levels, colors=&#39;k&#39;, origin=&#39;image&#39;, extent=extent) ylim = axs[3].get_ylim() axs[3].set_ylim(ylim[::-1]) axs[3].set_title(&quot;Origin from rc, reversed y-axis&quot;) fig.colorbar(im, ax=axs[3]) fig.tight_layout() plt.show() Python # https://matplotlib.org/gallery/images_contours_and_fields/irregulardatagrid.html#sphx-glr-gallery-images-contours-and-fields-irregulardatagrid-py import matplotlib.pyplot as plt import matplotlib.tri as tri import numpy as np np.random.seed(19680801) npts = 200 ngridx = 100 ngridy = 200 x = np.random.uniform(-2, 2, npts) y = np.random.uniform(-2, 2, npts) z = x * np.exp(-x**2 - y**2) fig, (ax1, ax2) = plt.subplots(nrows=2) # ----------------------- # Interpolation on a grid # ----------------------- # A contour plot of irregularly spaced data coordinates # via interpolation on a grid. # Create grid values first. xi = np.linspace(-2.1, 2.1, ngridx) yi = np.linspace(-2.1, 2.1, ngridy) # Perform linear interpolation of the data (x,y) # on a grid defined by (xi,yi) triang = tri.Triangulation(x, y) interpolator = tri.LinearTriInterpolator(triang, z) Xi, Yi = np.meshgrid(xi, yi) zi = interpolator(Xi, Yi) # Note that scipy.interpolate provides means to interpolate data on a grid # as well. The following would be an alternative to the four lines above: #from scipy.interpolate import griddata #zi = griddata((x, y), z, (xi[None,:], yi[:,None]), method=&#39;linear&#39;) ax1.contour(xi, yi, zi, 14, linewidths=0.5, colors=&#39;k&#39;) cntr1 = ax1.contourf(xi, yi, zi, 14, cmap=&quot;RdBu_r&quot;) fig.colorbar(cntr1, ax=ax1) ax1.plot(x, y, &#39;ko&#39;, ms=3) ax1.axis((-2, 2, -2, 2)) ax1.set_title(&#39;grid and contour (%d points, %d grid points)&#39; % (npts, ngridx * ngridy)) # ---------- # Tricontour # ---------- # Directly supply the unordered, irregularly spaced coordinates # to tricontour. ax2.tricontour(x, y, z, 14, linewidths=0.5, colors=&#39;k&#39;) cntr2 = ax2.tricontourf(x, y, z, 14, cmap=&quot;RdBu_r&quot;) fig.colorbar(cntr2, ax=ax2) ax2.plot(x, y, &#39;ko&#39;, ms=3) ax2.axis((-2, 2, -2, 2)) ax2.set_title(&#39;tricontour (%d points)&#39; % npts) plt.subplots_adjust(hspace=0.5) plt.show() 5.4 Triangulation and Delauney maps Python from matplotlib.tri import Triangulation, TriAnalyzer, UniformTriRefiner import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np #----------------------------------------------------------------------------- # Analytical test function #----------------------------------------------------------------------------- def experiment_res(x, y): &quot;&quot;&quot; An analytic function representing experiment results &quot;&quot;&quot; x = 2. * x r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2) theta1 = np.arctan2(0.5 - x, 0.5 - y) r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2) theta2 = np.arctan2(-x - 0.2, -y - 0.2) z = (4 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(3 * theta1) + (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(5 * theta2) + 2 * (x**2 + y**2)) return (np.max(z) - z) / (np.max(z) - np.min(z)) #----------------------------------------------------------------------------- # Generating the initial data test points and triangulation for the demo #----------------------------------------------------------------------------- # User parameters for data test points n_test = 200 # Number of test data points, tested from 3 to 5000 for subdiv=3 subdiv = 3 # Number of recursive subdivisions of the initial mesh for smooth # plots. Values &gt;3 might result in a very high number of triangles # for the refine mesh: new triangles numbering = (4**subdiv)*ntri init_mask_frac = 0.0 # Float &gt; 0. adjusting the proportion of # (invalid) initial triangles which will be masked # out. Enter 0 for no mask. min_circle_ratio = .01 # Minimum circle ratio - border triangles with circle # ratio below this will be masked if they touch a # border. Suggested value 0.01; use -1 to keep # all triangles. # Random points random_gen = np.random.RandomState(seed=19680801) x_test = random_gen.uniform(-1., 1., size=n_test) y_test = random_gen.uniform(-1., 1., size=n_test) z_test = experiment_res(x_test, y_test) # meshing with Delaunay triangulation tri = Triangulation(x_test, y_test) ntri = tri.triangles.shape[0] # Some invalid data are masked out mask_init = np.zeros(ntri, dtype=bool) masked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac)) mask_init[masked_tri] = True tri.set_mask(mask_init) #----------------------------------------------------------------------------- # Improving the triangulation before high-res plots: removing flat triangles #----------------------------------------------------------------------------- # masking badly shaped triangles at the border of the triangular mesh. mask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio) tri.set_mask(mask) # refining the data refiner = UniformTriRefiner(tri) tri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv) # analytical &#39;results&#39; for comparison z_expected = experiment_res(tri_refi.x, tri_refi.y) # for the demo: loading the &#39;flat&#39; triangles for plot flat_tri = Triangulation(x_test, y_test) flat_tri.set_mask(~mask) #----------------------------------------------------------------------------- # Now the plots #----------------------------------------------------------------------------- # User options for plots plot_tri = True # plot of base triangulation plot_masked_tri = True # plot of excessively flat excluded triangles plot_refi_tri = False # plot of refined triangulation plot_expected = False # plot of analytical function values for comparison # Graphical options for tricontouring levels = np.arange(0., 1., 0.025) cmap = cm.get_cmap(name=&#39;Blues&#39;, lut=None) fig, ax = plt.subplots() ax.set_aspect(&#39;equal&#39;) ax.set_title(&quot;Filtering a Delaunay mesh\\n&quot; + &quot;(application to high-resolution tricontouring)&quot;) # 1) plot of the refined (computed) data contours: ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap, linewidths=[2.0, 0.5, 1.0, 0.5]) # 2) plot of the expected (analytical) data contours (dashed): if plot_expected: ax.tricontour(tri_refi, z_expected, levels=levels, cmap=cmap, linestyles=&#39;--&#39;) # 3) plot of the fine mesh on which interpolation was done: if plot_refi_tri: ax.triplot(tri_refi, color=&#39;0.97&#39;) # 4) plot of the initial &#39;coarse&#39; mesh: if plot_tri: ax.triplot(tri, color=&#39;0.7&#39;) # 4) plot of the unvalidated triangles from naive Delaunay Triangulation: if plot_masked_tri: ax.triplot(flat_tri, color=&#39;red&#39;) plt.show() Python # https://matplotlib.org/gallery/images_contours_and_fields/triinterp_demo.html#sphx-glr-gallery-images-contours-and-fields-triinterp-demo-py import matplotlib.pyplot as plt import matplotlib.tri as mtri import numpy as np # Create triangulation. x = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5]) y = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0]) triangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7], [5, 6, 8], [5, 8, 7], [7, 8, 9]] triang = mtri.Triangulation(x, y, triangles) # Interpolate to regularly-spaced quad grid. z = np.cos(1.5 * x) * np.cos(1.5 * y) xi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20)) interp_lin = mtri.LinearTriInterpolator(triang, z) zi_lin = interp_lin(xi, yi) interp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=&#39;geom&#39;) zi_cubic_geom = interp_cubic_geom(xi, yi) interp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind=&#39;min_E&#39;) zi_cubic_min_E = interp_cubic_min_E(xi, yi) # Set up the figure fig, axs = plt.subplots(nrows=2, ncols=2) axs = axs.flatten() # Plot the triangulation. axs[0].tricontourf(triang, z) axs[0].triplot(triang, &#39;ko-&#39;) axs[0].set_title(&#39;Triangular grid&#39;) # Plot linear interpolation to quad grid. axs[1].contourf(xi, yi, zi_lin) axs[1].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[1].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[1].set_title(&quot;Linear interpolation&quot;) # Plot cubic interpolation to quad grid, kind=geom axs[2].contourf(xi, yi, zi_cubic_geom) axs[2].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[2].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[2].set_title(&quot;Cubic interpolation,\\nkind=&#39;geom&#39;&quot;) # Plot cubic interpolation to quad grid, kind=min_E axs[3].contourf(xi, yi, zi_cubic_min_E) axs[3].plot(xi, yi, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[3].plot(xi.T, yi.T, &#39;k-&#39;, lw=0.5, alpha=0.5) axs[3].set_title(&quot;Cubic interpolation,\\nkind=&#39;min_E&#39;&quot;) fig.tight_layout() plt.show() 5.5 Contour maps Python import matplotlib.pyplot as plt import numpy as np # http://www.scipy-lectures.org/intro/matplotlib/auto_examples/plot_contour_ex.html def f(x, y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 -y ** 2) n = 256 x = np.linspace(-3, 3, n) y = np.linspace(-3, 3, n) X,Y = np.meshgrid(x, y) plt.axes([0.025, 0.025, 0.95, 0.95]) plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.hot) C = plt.contour(X, Y, f(X, Y), 8, colors=&#39;black&#39;, linewidth=.5) plt.clabel(C, inline=1, fontsize=10) plt.xticks(()) plt.yticks(()) plt.show() 5.6 Real time Python # https://matplotlib.org/gallery/lines_bars_and_markers/cohere.html#sphx-glr-gallery-lines-bars-and-markers-cohere-py import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) dt = 0.01 t = np.arange(0, 30, dt) nse1 = np.random.randn(len(t)) # white noise 1 nse2 = np.random.randn(len(t)) # white noise 2 # Two signals with a coherent part at 10Hz and a random part s1 = np.sin(2 * np.pi * 10 * t) + nse1 s2 = np.sin(2 * np.pi * 10 * t) + nse2 fig, axs = plt.subplots(2, 1) axs[0].plot(t, s1, t, s2) axs[0].set_xlim(0, 2) axs[0].set_xlabel(&#39;time&#39;) axs[0].set_ylabel(&#39;s1 and s2&#39;) axs[0].grid(True) cxy, f = axs[1].cohere(s1, s2, 256, 1. / dt) axs[1].set_ylabel(&#39;coherence&#39;) fig.tight_layout() plt.show() Python # https://matplotlib.org/gallery/scales/symlog_demo.html#sphx-glr-gallery-scales-symlog-demo-py import matplotlib.pyplot as plt import numpy as np dt = 0.01 x = np.arange(-50.0, 50.0, dt) y = np.arange(0, 100.0, dt) plt.subplot(311) plt.plot(x, y) plt.xscale(&#39;symlog&#39;) plt.ylabel(&#39;symlogx&#39;) plt.grid(True) plt.gca().xaxis.grid(True, which=&#39;minor&#39;) # minor grid on too plt.subplot(312) plt.plot(y, x) plt.yscale(&#39;symlog&#39;) plt.ylabel(&#39;symlogy&#39;) plt.subplot(313) plt.plot(x, np.sin(x / 3.0)) plt.xscale(&#39;symlog&#39;) plt.yscale(&#39;symlog&#39;, linthreshy=0.015) plt.grid(True) plt.ylabel(&#39;symlog both&#39;) plt.tight_layout() plt.show() Python # https://matplotlib.org/gallery/lines_bars_and_markers/step_demo.html#sphx-glr-gallery-lines-bars-and-markers-step-demo-py import numpy as np from numpy import ma import matplotlib.pyplot as plt x = np.arange(1, 7, 0.4) y0 = np.sin(x) y = y0.copy() + 2.5 plt.step(x, y, label=&#39;pre (default)&#39;) y -= 0.5 plt.step(x, y, where=&#39;mid&#39;, label=&#39;mid&#39;) y -= 0.5 plt.step(x, y, where=&#39;post&#39;, label=&#39;post&#39;) y = ma.masked_where((y0 &gt; -0.15) &amp; (y0 &lt; 0.15), y - 0.5) plt.step(x, y, label=&#39;masked (pre)&#39;) plt.legend() plt.xlim(0, 7) plt.ylim(-0.5, 4) plt.show() 5.7 Density plots Python # https://blogs.umass.edu/candela/computational-physics-in-python/ # Visualize the interference from two point sources, vectorized version. import numpy as np import matplotlib.pyplot as plt from numpy import pi,sqrt,sin wavelength = 5e-2 # wavelength (m) (this is 5cm as in Newman) k = 2*pi/wavelength # wavenumber (m^-1) aa0 = 1.0 # amplitude of the waves (arb. units) separation = 20e-2 # separation of centers (m) side = 100e-2 # side of the square (m) points = 500 # number of grid points along each side # Calculate the positions of the centers of the circles x1 = side/2 + separation/2 y1 = side/2 x2 = side/2 - separation/2 y2 = side/2 # Calculate an array aas with the sum of the two waves at a grid of points xs = np.linspace(0,side,points) # row vector of x&#39;s ys = np.linspace(0,side,points)[:,np.newaxis] # column vector of y&#39;s r1s = sqrt((xs-x1)**2+(ys-y1)**2) r2s = sqrt((xs-x2)**2+(ys-y2)**2) aas = aa0*sin(k*r1s) + aa0*sin(k*r2s) # Make the plot plt.figure(figsize=(9,6)) plt.imshow(aas,origin=&#39;lower&#39;,extent=[0,side,0,side]) plt.xlabel(&#39;x (m)&#39;) plt.ylabel(&#39;y (m)&#39;) # plt.gray() plt.colorbar() plt.show() "],["voxels.html", "Ch. 6 Voxels 6.1 Radial 6.2 Spherical 6.3 Solid cubes 6.4 Transparent cubicles 6.5 Semi-transparent 6.6 Opaque cubicles", " Ch. 6 Voxels R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 6.1 Radial Python # https://matplotlib.org/api/_as_gen/mpl_toolkits.mplot3d.axes3d.Axes3D.html #======================================================= #3D voxel / volumetric plot with cylindrical coordinates #======================================================= #Demonstrates using the ``x, y, z`` arguments of ``ax.voxels``. import matplotlib.pyplot as plt import matplotlib.colors import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def midpoints(x): sl = () for i in range(x.ndim): x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0 sl += np.index_exp[:] return x # prepare some coordinates, and attach rgb values to each r, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j] x = r*np.cos(theta) y = r*np.sin(theta) rc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z) # define a wobbly torus about [0.7, *, 0] sphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 &lt; 0.2**2 # combine the color components hsv = np.zeros(sphere.shape + (3,)) hsv[..., 0] = thetac / (np.pi*2) hsv[..., 1] = rc hsv[..., 2] = zc + 0.5 colors = matplotlib.colors.hsv_to_rgb(hsv) # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(x, y, z, sphere, facecolors=colors, edgecolors=np.clip(2*colors - 0.5, 0, 1), # brighter linewidth=0.5) plt.show() 6.2 Spherical Python import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def midpoints(x): sl = () for i in range(x.ndim): x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0 sl += np.index_exp[:] return x # prepare some coordinates, and attach rgb values to each r, g, b = np.indices((17, 17, 17)) / 16.0 rc = midpoints(r) gc = midpoints(g) bc = midpoints(b) # define a sphere about [0.5, 0.5, 0.5] sphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 &lt; 0.5**2 # combine the color components colors = np.zeros(sphere.shape + (3,)) colors[..., 0] = rc colors[..., 1] = gc colors[..., 2] = bc # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(r, g, b, sphere, facecolors=colors, edgecolors=np.clip(2*colors - 0.5, 0, 1), # brighter linewidth=0.5) ax.set(xlabel=&#39;r&#39;, ylabel=&#39;g&#39;, zlabel=&#39;b&#39;) plt.show() 6.3 Solid cubes Python # https://github.com/matplotlib/matplotlib/blob/master/examples/mplot3d/voxels.py import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import # prepare some coordinates x, y, z = np.indices((8, 8, 8)) # draw cuboids in the top left and bottom right corners, and a link between them cube1 = (x &lt; 3) &amp; (y &lt; 3) &amp; (z &lt; 3) cube2 = (x &gt;= 5) &amp; (y &gt;= 5) &amp; (z &gt;= 5) link = abs(x - y) + abs(y - z) + abs(z - x) &lt;= 2 # combine the objects into a single boolean array voxels = cube1 | cube2 | link # set the colors of each object colors = np.empty(voxels.shape, dtype=object) colors[link] = &#39;red&#39; colors[cube1] = &#39;blue&#39; colors[cube2] = &#39;green&#39; # and plot everything fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(voxels, facecolors=colors, edgecolor=&#39;k&#39;) plt.show() Python # https://stackoverflow.com/a/49281004/5270873 from mpl_toolkits.mplot3d import Axes3D from mpl_toolkits.mplot3d.art3d import Poly3DCollection import numpy as np import matplotlib.pyplot as plt def cuboid_data2(o, size=(1,1,1)): X = [[[0, 1, 0], [0, 0, 0], [1, 0, 0], [1, 1, 0]], [[0, 0, 0], [0, 0, 1], [1, 0, 1], [1, 0, 0]], [[1, 0, 1], [1, 0, 0], [1, 1, 0], [1, 1, 1]], [[0, 0, 1], [0, 0, 0], [0, 1, 0], [0, 1, 1]], [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]], [[0, 1, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1]]] X = np.array(X).astype(float) for i in range(3): X[:,:,i] *= size[i] X += np.array(o) return X def plotCubeAt2(positions,sizes=None,colors=None, **kwargs): if not isinstance(colors,(list,np.ndarray)): colors=[&quot;C0&quot;]*len(positions) if not isinstance(sizes,(list,np.ndarray)): sizes=[(1,1,1)]*len(positions) g = [] for p,s,c in zip(positions,sizes,colors): g.append( cuboid_data2(p, size=s) ) return Poly3DCollection(np.concatenate(g), facecolors=np.repeat(colors,6), **kwargs) positions = [(-3,5,-2),(1,7,1)] sizes = [(4,5,3), (3,3,7)] colors = [&quot;crimson&quot;,&quot;limegreen&quot;] fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_aspect(&#39;auto&#39;) pc = plotCubeAt2(positions,sizes,colors=colors, edgecolor=&quot;k&quot;) ax.add_collection3d(pc) ax.set_xlim([-4,6]) ax.set_ylim([4,13]) ax.set_zlim([-3,9]) plt.show() 6.4 Transparent cubicles Python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) def explode(data): shape_arr = np.array(data.shape) size = shape_arr[:3]*2 - 1 exploded = np.zeros(np.concatenate([size, shape_arr[3:]]), dtype=data.dtype) exploded[::2, ::2, ::2] = data return exploded def expand_coordinates(indices): x, y, z = indices x[1::2, :, :] += 1 y[:, 1::2, :] += 1 z[:, :, 1::2] += 1 return x, y, z ax = make_ax() colors = np.array([[[&#39;#1f77b430&#39;]*3]*3]*3) colors[1,1,1] = &#39;#ff0000ff&#39; colors = explode(colors) filled = explode(np.ones((3, 3, 3))) x, y, z = expand_coordinates(np.indices(np.array(filled.shape) + 1)) ax.voxels(x, y, z, filled, facecolors=colors, edgecolors=&#39;gray&#39;) plt.show() Python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax() ax.voxels(filled, facecolors=&#39;#1f77b430&#39;, edgecolors=&#39;gray&#39;) plt.show() Python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax() ax.voxels(np.ones((3, 3, 3)), facecolors=&#39;#1f77b430&#39;, edgecolors=&#39;gray&#39;) plt.show() 6.5 Semi-transparent Python # https://matplotlib.org/gallery/mplot3d/voxels_numpy_logo.html import matplotlib.pyplot as plt import numpy as np # This import registers the 3D projection, but is otherwise unused. from mpl_toolkits.mplot3d import Axes3D # noqa: F401 unused import def explode(data): size = np.array(data.shape)*2 data_e = np.zeros(size - 1, dtype=data.dtype) data_e[::2, ::2, ::2] = data return data_e # build up the numpy logo n_voxels = np.zeros((4, 3, 4), dtype=bool) n_voxels[0, 0, :] = True n_voxels[-1, 0, :] = True n_voxels[1, 0, 2] = True n_voxels[2, 0, 1] = True facecolors = np.where(n_voxels, &#39;#FFD65DC0&#39;, &#39;#7A88CCC0&#39;) edgecolors = np.where(n_voxels, &#39;#BFAB6E&#39;, &#39;#7D84A6&#39;) filled = np.ones(n_voxels.shape) # upscale the above voxel image, leaving gaps filled_2 = explode(filled) fcolors_2 = explode(facecolors) ecolors_2 = explode(edgecolors) # Shrink the gaps x, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2 x[0::2, :, :] += 0.05 y[:, 0::2, :] += 0.05 z[:, :, 0::2] += 0.05 x[1::2, :, :] += 0.95 y[:, 1::2, :] += 0.95 z[:, :, 1::2] += 0.95 fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2) plt.show() 6.6 Opaque cubicles Python import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def make_ax(grid=False): fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) ax.grid(grid) return ax filled = np.array([ [[1, 0, 1], [0, 0, 1], [0, 1, 0]], [[0, 1, 1], [1, 0, 0], [1, 0, 1]], [[1, 1, 0], [1, 1, 1], [0, 0, 0]] ]) ax = make_ax(True) ax.voxels(filled, edgecolors=&#39;gray&#39;) plt.show() "],["seaborn.html", "Ch. 7 Seaborn 7.1 Error bands 7.2 Boxplots 7.3 Facets 7.4 Functions 7.5 Scatter plot matrix", " Ch. 7 Seaborn R library(reticulate) use_condaenv(&quot;r-python&quot;, required = TRUE) 7.1 Error bands Python # https://seaborn.pydata.org/examples/errorband_lineplots.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;darkgrid&quot;) # Load an example dataset with long-form data fmri = sns.load_dataset(&quot;fmri&quot;) # Plot the responses for different events and regions sns.lineplot(x=&quot;timepoint&quot;, y=&quot;signal&quot;, hue=&quot;region&quot;, style=&quot;event&quot;, data=fmri) plt.show() 7.2 Boxplots Python # https://seaborn.pydata.org/examples/horizontal_boxplot.html import seaborn as sns import matplotlib.pyplot as plt sns.set_theme(style=&quot;ticks&quot;) # Initialize the figure with a logarithmic x axis f, ax = plt.subplots(figsize=(7, 6)) ax.set_xscale(&quot;log&quot;) # Load the example planets dataset planets = sns.load_dataset(&quot;planets&quot;) # Plot the orbital period with horizontal boxes sns.boxplot(x=&quot;distance&quot;, y=&quot;method&quot;, data=planets, whis=[0, 100], width=.6, palette=&quot;vlag&quot;) # Add in points to show each observation sns.stripplot(x=&quot;distance&quot;, y=&quot;method&quot;, data=planets, size=4, color=&quot;.3&quot;, linewidth=0) # Tweak the visual presentation ax.xaxis.grid(True) ax.set(ylabel=&quot;&quot;) sns.despine(trim=True, left=True) plt.show() 7.3 Facets Python # https://seaborn.pydata.org/examples/timeseries_facets.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;dark&quot;) flights = sns.load_dataset(&quot;flights&quot;) # Plot each year&#39;s time series in its own facet g = sns.relplot( data=flights, x=&quot;month&quot;, y=&quot;passengers&quot;, col=&quot;year&quot;, hue=&quot;year&quot;, kind=&quot;line&quot;, palette=&quot;crest&quot;, linewidth=4, zorder=5, col_wrap=3, height=2, aspect=1.5, legend=False, ) # Iterate over each subplot to customize further for year, ax in g.axes_dict.items(): # Add the title as an annotation within the plot ax.text(.8, .85, year, transform=ax.transAxes, fontweight=&quot;bold&quot;) # Plot every year&#39;s time series in the background sns.lineplot( data=flights, x=&quot;month&quot;, y=&quot;passengers&quot;, units=&quot;year&quot;, estimator=None, color=&quot;.7&quot;, linewidth=1, ax=ax, ) # Reduce the frequency of the x axis ticks ax.set_xticks(ax.get_xticks()[::2]) # Tweak the supporting aspects of the plot g.set_titles(&quot;&quot;) g.set_axis_labels(&quot;&quot;, &quot;Passengers&quot;) g.tight_layout() plt.show() Python import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;darkgrid&quot;) tips = sns.load_dataset(&quot;tips&quot;) fmri = sns.load_dataset(&quot;fmri&quot;) sns.relplot(x=&quot;timepoint&quot;, y=&quot;signal&quot;, hue=&quot;event&quot;, style=&quot;event&quot;, col=&quot;subject&quot;, col_wrap=5, height=3, aspect=.75, linewidth=2.5, kind=&quot;line&quot;, data=fmri.query(&quot;region == &#39;frontal&#39;&quot;)); plt.show() 7.4 Functions Python from __future__ import print_function, division import matplotlib.pyplot as plt import numpy as np import pandas as pd x = np.linspace(0, 10, 1000) plt.style.use(&#39;ggplot&#39;) plt.plot(x, np.sin(x), x, np.cos(x)); plt.show() 7.5 Scatter plot matrix Python # https://seaborn.pydata.org/examples/scatterplot_matrix.html import matplotlib.pyplot as plt import seaborn as sns sns.set_theme(style=&quot;ticks&quot;) df = sns.load_dataset(&quot;penguins&quot;) sns.pairplot(df, hue=&quot;species&quot;) plt.show() "],["advanced.html", "Ch. 8 Advanced 8.1 Adding labels 8.2 Subplots 8.3 Change of axes", " Ch. 8 Advanced R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 8.1 Adding labels Math symbols printing with Latex. \\(r&#39;s(t) = \\mathcal{A}\\/\\sin(2 \\omega t)&#39;\\) \\(\\mathbb{blackboard}\\) Python import matplotlib.pyplot as plt import numpy as np mu, sigma = 100, 15 x = mu + sigma * np.random.randn(10000) # the histogram of the data n, bins, patches = plt.hist(x, 50, density=1, facecolor=&#39;g&#39;, alpha=0.75) plt.xlabel(&#39;Smarts&#39;) plt.ylabel(&#39;Probability&#39;) plt.title(&#39;Histogram of IQ&#39;) plt.text(60, .025, r&#39;$\\mu=100,\\ \\sigma=15$&#39;) plt.axis([40, 160, 0, 0.03]) plt.grid(True) plt.show() Python # http://scipy-lectures.org/_downloads/ScipyLectures-simple.pdf import numpy as np import matplotlib.pyplot as plt eqs = [] eqs.append((r&quot;$W^{3\\beta}_{\\delta_1 \\rho_1 \\sigma_2} = U^{3\\beta}_{\\delta_1 \\rho_1} + \\frac{1} {8 \\pi 2} \\int^{\\alpha_2}_{\\alpha_2} d \\alpha^\\prime_2 \\left[\\frac{ U^{2\\beta}_{\\delta_1 \\rho_1} - \\alpha^\\prime_2U^{1\\beta}_{\\rho_1 \\sigma_2}}{U^{0\\beta}_{\\rho_1 \\sigma_2}} \\right]$&quot;)) # eq1 eqs.append((r&quot;$\\frac{d\\rho}{d t} + \\rho \\vec{v}\\cdot\\nabla\\vec{v} = -\\nabla p + \\mu\\nabla^2 \\vec{v} + \\rho \\vec{g}$&quot;)) # eq2 eqs.append((r&quot;$\\int_{-\\infty}^\\infty e^{-x^2}dx=\\sqrt{\\pi}$&quot;)) # eq3 eqs.append((r&quot;$E = mc^2 = \\sqrt{ {m_0}^2 c^4 + p^2 c^2}$&quot;)) # eq4 eqs.append((r&quot;$F_G = G\\frac{m_1m_2}{r^2}$&quot;)) # eq5 plt.axes([0.025, 0.025, 0.95, 0.95]) for i in range(24): index = np.random.randint(0, len(eqs)) eq = eqs[index] size = np.random.uniform(12, 32) x,y = np.random.uniform(0, 1, 2) alpha = np.random.uniform(0.25, .75) plt.text(x, y, eq, ha=&#39;center&#39;, va=&#39;center&#39;, color=&quot;#11557c&quot;, alpha=alpha,transform=plt.gca().transAxes, fontsize=size, clip_on=True) plt.xticks([]) plt.yticks([]) plt.show() 8.2 Subplots Python # https://matplotlib.org/gallery/subplots_axes_and_figures/subplots_adjust.html#sphx-glr-gallery-subplots-axes-and-figures-subplots-adjust-py import matplotlib.pyplot as plt import numpy as np # Fixing random state for reproducibility np.random.seed(19680801) plt.subplot(211) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplot(212) plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r) plt.subplots_adjust(bottom=0.1, right=0.8, top=0.9) cax = plt.axes([0.85, 0.1, 0.075, 0.8]) plt.colorbar(cax=cax) plt.show() Python # https://matplotlib.org/gallery/text_labels_and_annotations/figlegend_demo.html#sphx-glr-gallery-text-labels-and-annotations-figlegend-demo-py import numpy as np import matplotlib.pyplot as plt fig, axs = plt.subplots(1, 2) x = np.arange(0.0, 2.0, 0.02) y1 = np.sin(2 * np.pi * x) y2 = np.exp(-x) l1, l2 = axs[0].plot(x, y1, &#39;rs-&#39;, x, y2, &#39;go&#39;) y3 = np.sin(4 * np.pi * x) y4 = np.exp(-2 * x) l3, l4 = axs[1].plot(x, y3, &#39;yd-&#39;, x, y4, &#39;k^&#39;) fig.legend((l1, l2), (&#39;Line 1&#39;, &#39;Line 2&#39;), &#39;upper left&#39;) fig.legend((l3, l4), (&#39;Line 3&#39;, &#39;Line 4&#39;), &#39;upper right&#39;) plt.tight_layout() plt.show() Python import matplotlib.pyplot as plt import numpy as np names = [&#39;group_a&#39;, &#39;group_b&#39;, &#39;group_c&#39;] values = [1, 10, 100] plt.figure(figsize=(9, 3)) plt.subplot(131) plt.bar(names, values) plt.subplot(132) plt.scatter(names, values) plt.subplot(133) plt.plot(names, values) plt.suptitle(&#39;Categorical Plotting&#39;) plt.show() Python # https://www.python-course.eu/matplotlib_multiple_figures.php import matplotlib.gridspec as gridspec import matplotlib.pyplot as plt import numpy as np plt.figure(figsize=(6, 4)) G = gridspec.GridSpec(3, 3) X = np.linspace(0, 2 * np.pi, 50, endpoint=True) F1 = 2.8 * np.cos(X) F2 = 5 * np.sin(X) F3 = 0.3 * np.sin(X) axes_1 = plt.subplot(G[0, :]) axes_1.plot(X, F1, &#39;r-&#39;, X, F2) axes_2 = plt.subplot(G[1, :-1]) axes_2.plot(X, F3) axes_3 = plt.subplot(G[1:, -1]) axes_3.plot([1,2,3,4], [1,10,100,1000], &#39;b-&#39;) axes_4 = plt.subplot(G[-1, 0]) axes_4.plot([1,2,3,4], [47, 11, 42, 60], &#39;r-&#39;) axes_5 = plt.subplot(G[-1, -2]) axes_5.plot([1,2,3,4], [7, 5, 4, 3.8]) plt.tight_layout() plt.show() Python # https://matplotlib.org/gallery/text_labels_and_annotations/figlegend_demo.html#sphx-glr-gallery-text-labels-and-annotations-figlegend-demo-py import numpy as np import matplotlib.pyplot as plt fig, axs = plt.subplots(1, 2) x = np.arange(0.0, 2.0, 0.02) y1 = np.sin(2 * np.pi * x) y2 = np.exp(-x) l1, l2 = axs[0].plot(x, y1, &#39;rs-&#39;, x, y2, &#39;go&#39;) y3 = np.sin(4 * np.pi * x) y4 = np.exp(-2 * x) l3, l4 = axs[1].plot(x, y3, &#39;yd-&#39;, x, y4, &#39;k^&#39;) fig.legend((l1, l2), (&#39;Line 1&#39;, &#39;Line 2&#39;), &#39;upper left&#39;) fig.legend((l3, l4), (&#39;Line 3&#39;, &#39;Line 4&#39;), &#39;upper right&#39;) plt.tight_layout() plt.show() 8.3 Change of axes Python import numpy as np import matplotlib.pyplot as plt # Fixing random state for reproducibility np.random.seed(19680801) # make up some data in the open interval (0, 1) y = np.random.normal(loc=0.5, scale=0.4, size=1000) y = y[(y &gt; 0) &amp; (y &lt; 1)] y.sort() x = np.arange(len(y)) # plot with various axes scales plt.figure() # linear plt.subplot(221) plt.plot(x, y) plt.yscale(&#39;linear&#39;) plt.title(&#39;linear&#39;) plt.grid(True) # log plt.subplot(222) plt.plot(x, y) plt.yscale(&#39;log&#39;) plt.title(&#39;log&#39;) plt.grid(True) # symmetric log plt.subplot(223) plt.plot(x, y - y.mean()) plt.yscale(&#39;symlog&#39;, linthresh=0.01) plt.title(&#39;symlog&#39;) plt.grid(True) # logit plt.subplot(224) plt.plot(x, y) plt.yscale(&#39;logit&#39;) plt.title(&#39;logit&#39;) plt.grid(True) # Adjust the subplot layout, because the logit one may take more space # than usual, due to y-tick labels like &quot;1 - 10^{-3}&quot; plt.subplots_adjust(top=0.92, bottom=0.08, left=0.10, right=0.95, hspace=0.25, wspace=0.35) plt.show() "],["beyond-matplotlib.html", "Ch. 9 Beyond matplotlib 9.1 brokenaxis 9.2 yellowbrick", " Ch. 9 Beyond matplotlib R library(reticulate) reticulate::use_condaenv(&quot;r-python&quot;) 9.1 brokenaxis 9.1.1 Usage # https://github.com/bendichter/brokenaxes/blob/master/examples/plot_usage.py import matplotlib.pyplot as plt from brokenaxes import brokenaxes import numpy as np fig = plt.figure(figsize=(5,2)) bax = brokenaxes(xlims=((0, .1), (.4, .7)), ylims=((-1, .7), (.79, 1)), hspace=.05) x = np.linspace(0, 1, 100) bax.plot(x, np.sin(10 * x), label=&#39;sin&#39;) bax.plot(x, np.cos(10 * x), label=&#39;cos&#39;) bax.legend(loc=3) bax.set_xlabel(&#39;time&#39;) bax.set_ylabel(&#39;value&#39;) 9.1.2 Subplots # https://github.com/bendichter/brokenaxes/blob/master/examples/plot_subplots.py from brokenaxes import brokenaxes from matplotlib.gridspec import GridSpec import numpy as np sps1, sps2 = GridSpec(2,1) bax = brokenaxes(xlims=((.1, .3),(.7, .8)), subplot_spec=sps1) x = np.linspace(0, 1, 100) bax.plot(x, np.sin(x*30), ls=&#39;:&#39;, color=&#39;m&#39;) x = np.random.poisson(3, 1000) bax = brokenaxes(xlims=((0, 2.5), (3, 6)), subplot_spec=sps2) bax.hist(x, histtype=&#39;bar&#39;) 9.1.3 Log scales # https://github.com/bendichter/brokenaxes/blob/master/examples/plot_logscales.py # Log scales # ========== # Brokenaxe compute automatically the correct layout for a 1:1 scale. However, for # logarithmic scales, the 1:1 scale has to be adapted. This is done via the # `yscale` or `xscale` arguments. import matplotlib.pyplot as plt from brokenaxes import brokenaxes import numpy as np fig = plt.figure(figsize=(5,5)) bax = brokenaxes(xlims=((1, 500), (600, 10000)), ylims=((1, 500), (600, 10000)), hspace=.15, xscale=&#39;log&#39;, yscale=&#39;log&#39;) x = np.logspace(0.0, 4, 100) bax.loglog(x, x, label=&#39;$y=x=10^{0}$ to $10^{4}$&#39;) bax.legend(loc=&#39;best&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;major&#39;, ls=&#39;-&#39;) bax.grid(axis=&#39;both&#39;, which=&#39;minor&#39;, ls=&#39;--&#39;, alpha=0.4) bax.set_xlabel(&#39;x&#39;) bax.set_ylabel(&#39;y&#39;) plt.show() 9.1.4 Different scales Python # https://github.com/bendichter/brokenaxes/blob/master/examples/plot_different_scales.py # Different scales with brokenaxes # ================================ # This example shows how to customize the scales and the ticks of each broken # axes. ############################################################################# # brokenaxes lets you choose the aspect ratio of each sub-axes thanks to the # `height_ratios` and `width_ratios` to over-pass the default 1:1 scale for all # axes. However, by default the ticks spacing are still identical for all axes. # In this example, we present how to customize the ticks of your brokenaxes. import numpy as np import matplotlib.pyplot as plt from brokenaxes import brokenaxes import matplotlib.ticker as ticker def make_plot(): x = np.linspace(0, 5*2*np.pi, 300) y1 = np.sin(x)*100 y2 = np.sin(x+np.pi)*5 + 90 y3 = 30*np.exp(-x) - 50 y4 = 90 + (1-np.exp(6/x)) bax = brokenaxes( ylims=[(-100, 0), (80, 100)], xlims=[(0, 5), (10, 30)], height_ratios=[1, 3], width_ratios=[3, 5] ) bax.plot(x, y1, label=&quot;Big sin&quot;) bax.plot(x, y2, label=&quot;Small sin&quot;) bax.plot(x, y3, label=&quot;Exponential 1&quot;) bax.plot(x, y4, &#39;--&#39;, label=&quot;Exponential 2&quot;) bax.legend(loc=&quot;lower right&quot;) bax.set_title(&quot;Example for different scales for the x and y axis&quot;) return bax ############################################################################# # Use the AutoLocator() ticker # ---------------------------- plt.figure() bax = make_plot() # Then, we get the different axes created and set the ticks according to the # axe x and y limits. for i, ax in enumerate(bax.last_row): ax.xaxis.set_major_locator(ticker.AutoLocator()) ax.set_xlabel(&#39;xscale {i}&#39;.format(i=i)) for i, ax in enumerate(bax.first_col): ax.yaxis.set_major_locator(ticker.AutoLocator()) ax.set_ylabel(&#39;yscale {i}&#39;.format(i=i)) ############################################################################## # .. note:: It is not necessary to loop through all the axes since they all # share the same x and y limits in a given column or row. ############################################################################## # Manually set the ticks # ---------------------- # # Since brokenaxes return normal matplotlib axes, you could also set them # manually. fig2 = plt.figure() bax = make_plot() bax.first_col[0].set_yticks([80, 85, 90, 95, 100]) bax.first_col[1].set_yticks([-100, -50, 0]) bax.last_row[0].set_xticks([0, 1, 2, 3, 4, 5]) bax.last_row[1].set_xticks([10, 20, 30]) plt.show() 9.2 yellowbrick 9.2.1 Pearson correlation # https://www.scikit-yb.org/en/latest/quickstart.html import pandas as pd from yellowbrick.datasets import load_bikeshare X, y = load_bikeshare() print(X.head()) from yellowbrick.features import Rank2D visualizer = Rank2D(algorithm=&quot;pearson&quot;) visualizer.fit_transform(X) visualizer.show() 9.2.2 Scatter diagram # https://www.scikit-yb.org/en/latest//quickstart-2.py from yellowbrick.features import JointPlotVisualizer visualizer = JointPlotVisualizer(columns=[&#39;temp&#39;, &#39;feelslike&#39;]) visualizer.fit_transform(X, y) visualizer.show() 9.2.3 Residuals plot # https://www.scikit-yb.org/en/latest//quickstart-3.py from yellowbrick.regressor import ResidualsPlot from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split # Create training and test sets X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.1 ) visualizer = ResidualsPlot(LinearRegression()) visualizer.fit(X_train, y_train) visualizer.score(X_test, y_test) visualizer.show() 9.2.4 Discrimination threshold from yellowbrick.classifier import discrimination_threshold from sklearn.linear_model import LogisticRegression from yellowbrick.datasets import load_spam X, y = load_spam() visualizer = discrimination_threshold( LogisticRegression(multi_class=&quot;auto&quot;, solver=&quot;liblinear&quot;), X, y ) 9.2.5 Intercluster distance Python # https://www.scikit-yb.org/en/latest//oneliners-17.py from yellowbrick.datasets import load_nfl from sklearn.cluster import MiniBatchKMeans from yellowbrick.cluster import intercluster_distance X, y = load_nfl() visualizer = intercluster_distance(MiniBatchKMeans(5, random_state=777), X) "]]
